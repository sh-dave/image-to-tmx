// Generated by Haxe 4.0.0-preview.5+7eb789f54
(function ($global) { "use strict";
var $hxClasses = {},$estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}var HxOverrides = function() { };
$hxClasses["HxOverrides"] = HxOverrides;
HxOverrides.__name__ = true;
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var Lambda = function() { };
$hxClasses["Lambda"] = Lambda;
Lambda.__name__ = true;
Lambda.exists = function(it,f) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			return true;
		}
	}
	return false;
};
var mcli_CommandLine = function() {
	this._preventDefault = false;
};
$hxClasses["mcli.CommandLine"] = mcli_CommandLine;
mcli_CommandLine.__name__ = true;
mcli_CommandLine.prototype = {
	getArguments: function() {
		return [];
	}
	,preventDefault: function() {
		this._preventDefault = true;
	}
	,showUsage: function() {
		return mcli_Dispatch.showUsageOf(this.getArguments());
	}
	,toString: function() {
		return this.showUsage();
	}
	,__class__: mcli_CommandLine
};
var mcli_internal_Kind = $hxEnums["mcli.internal.Kind"] = { __ename__ : true, __constructs__ : ["Message","Flag","VarHash","Var","Function","SubDispatch"]
	,Message: {_hx_index:0,__enum__:"mcli.internal.Kind",toString:$estr}
	,Flag: {_hx_index:1,__enum__:"mcli.internal.Kind",toString:$estr}
	,VarHash: ($_=function(key,value,valueIsArray) { return {_hx_index:2,key:key,value:value,valueIsArray:valueIsArray,__enum__:"mcli.internal.Kind",toString:$estr}; },$_.__params__ = ["key","value","valueIsArray"],$_)
	,Var: ($_=function(t) { return {_hx_index:3,t:t,__enum__:"mcli.internal.Kind",toString:$estr}; },$_.__params__ = ["t"],$_)
	,Function: ($_=function(args,varArgs) { return {_hx_index:4,args:args,varArgs:varArgs,__enum__:"mcli.internal.Kind",toString:$estr}; },$_.__params__ = ["args","varArgs"],$_)
	,SubDispatch: {_hx_index:5,__enum__:"mcli.internal.Kind",toString:$estr}
};
mcli_internal_Kind.__empty_constructs__ = [mcli_internal_Kind.Message,mcli_internal_Kind.Flag,mcli_internal_Kind.SubDispatch];
var MapWriter = function() {
	this.tileWidth = 16;
	this.tileHeight = 16;
	mcli_CommandLine.call(this);
};
$hxClasses["MapWriter"] = MapWriter;
MapWriter.__name__ = true;
MapWriter.main = function() {
	new mcli_Dispatch(process.argv.slice(2)).dispatch(new MapWriter());
};
MapWriter.__super__ = mcli_CommandLine;
MapWriter.prototype = $extend(mcli_CommandLine.prototype,{
	runDefault: function() {
		if(this.inputTileset == null || this.inputImage == null) {
			this.help();
			return;
		}
		var tileset = new Tileset(this.inputTileset,this.tileWidth,this.tileHeight);
		var map = new Tilemap(this.inputImage,tileset,this.tileWidth,this.tileHeight,this.inputTileset);
		map.write();
	}
	,help: function() {
		var v = this.showUsage();
		process.stdout.write(Std.string(v));
		process.stdout.write("\n");
		process.exit(0);
	}
	,getArguments: function() {
		return MapWriter.ARGUMENTS.concat(mcli_CommandLine.prototype.getArguments.call(this));
	}
	,__class__: MapWriter
});
Math.__name__ = true;
var Reflect = function() { };
$hxClasses["Reflect"] = Reflect;
Reflect.__name__ = true;
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( e ) {
		var e1 = (e instanceof js__$Boot_HaxeError) ? e.val : e;
		return null;
	}
};
Reflect.getProperty = function(o,field) {
	var tmp;
	if(o == null) {
		return null;
	} else {
		var tmp1;
		if(o.__properties__) {
			tmp = o.__properties__["get_" + field];
			tmp1 = tmp;
		} else {
			tmp1 = false;
		}
		if(tmp1) {
			return o[tmp]();
		} else {
			return o[field];
		}
	}
};
Reflect.setProperty = function(o,field,value) {
	var tmp;
	var tmp1;
	if(o.__properties__) {
		tmp = o.__properties__["set_" + field];
		tmp1 = tmp;
	} else {
		tmp1 = false;
	}
	if(tmp1) {
		o[tmp](value);
	} else {
		o[field] = value;
	}
};
Reflect.compare = function(a,b) {
	if(a == b) {
		return 0;
	} else if(a > b) {
		return 1;
	} else {
		return -1;
	}
};
var Std = function() { };
$hxClasses["Std"] = Std;
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	var v = parseInt(x, x && x[0]=="0" && (x[1]=="x" || x[1]=="X") ? 16 : 10);
	if(isNaN(v)) {
		return null;
	}
	return v;
};
var StringBuf = function() {
	this.b = "";
};
$hxClasses["StringBuf"] = StringBuf;
StringBuf.__name__ = true;
StringBuf.prototype = {
	__class__: StringBuf
};
var StringTools = function() { };
$hxClasses["StringTools"] = StringTools;
StringTools.__name__ = true;
StringTools.htmlEscape = function(s,quotes) {
	var buf_b = "";
	var _g_offset = 0;
	var _g_s = s;
	while(_g_offset < _g_s.length) {
		var c = _g_s.charCodeAt(_g_offset++);
		if(c >= 55296 && c < 56319) {
			c = c - 55232 << 10 | _g_s.charCodeAt(_g_offset++) & 1023;
		}
		var code = c;
		switch(code) {
		case 34:
			if(quotes) {
				buf_b += "&quot;";
			} else {
				buf_b += String.fromCodePoint(code);
			}
			break;
		case 38:
			buf_b += "&amp;";
			break;
		case 39:
			if(quotes) {
				buf_b += "&#039;";
			} else {
				buf_b += String.fromCodePoint(code);
			}
			break;
		case 60:
			buf_b += "&lt;";
			break;
		case 62:
			buf_b += "&gt;";
			break;
		default:
			buf_b += String.fromCodePoint(code);
		}
	}
	return buf_b;
};
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
StringTools.rpad = function(s,c,l) {
	if(c.length <= 0) {
		return s;
	}
	var buf_b = "";
	buf_b += s == null ? "null" : "" + s;
	while(buf_b.length < l) buf_b += c == null ? "null" : "" + c;
	return buf_b;
};
StringTools.replace = function(s,sub,by) {
	return s.split(sub).join(by);
};
var haxe_io_Output = function() { };
$hxClasses["haxe.io.Output"] = haxe_io_Output;
haxe_io_Output.__name__ = true;
var _$Sys_FileOutput = function(fd) {
	this.fd = fd;
};
$hxClasses["_Sys.FileOutput"] = _$Sys_FileOutput;
_$Sys_FileOutput.__name__ = true;
_$Sys_FileOutput.__super__ = haxe_io_Output;
_$Sys_FileOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(c) {
		js_node_Fs.writeSync(this.fd,String.fromCodePoint(c));
	}
	,writeBytes: function(s,pos,len) {
		var data = s.b;
		return js_node_Fs.writeSync(this.fd,new js_node_buffer_Buffer(data.buffer,data.byteOffset,s.length),pos,len);
	}
	,writeString: function(s,encoding) {
		js_node_Fs.writeSync(this.fd,s);
	}
	,flush: function() {
		js_node_Fs.fsyncSync(this.fd);
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
	,__class__: _$Sys_FileOutput
});
var haxe_io_Input = function() { };
$hxClasses["haxe.io.Input"] = haxe_io_Input;
haxe_io_Input.__name__ = true;
haxe_io_Input.prototype = {
	readByte: function() {
		throw new js__$Boot_HaxeError("Not implemented");
	}
	,readBytes: function(s,pos,len) {
		var k = len;
		var b = s.b;
		if(pos < 0 || len < 0 || pos + len > s.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		try {
			while(k > 0) {
				b[pos] = this.readByte();
				++pos;
				--k;
			}
		} catch( eof ) {
			var eof1 = (eof instanceof js__$Boot_HaxeError) ? eof.val : eof;
			if((eof1 instanceof haxe_io_Eof)) {
				var eof2 = eof1;
			} else {
				throw eof;
			}
		}
		return len - k;
	}
	,set_bigEndian: function(b) {
		this.bigEndian = b;
		return b;
	}
	,readFullBytes: function(s,pos,len) {
		while(len > 0) {
			var k = this.readBytes(s,pos,len);
			if(k == 0) {
				throw new js__$Boot_HaxeError(haxe_io_Error.Blocked);
			}
			pos += k;
			len -= k;
		}
	}
	,read: function(nbytes) {
		var s = new haxe_io_Bytes(new ArrayBuffer(nbytes));
		var p = 0;
		while(nbytes > 0) {
			var k = this.readBytes(s,p,nbytes);
			if(k == 0) {
				throw new js__$Boot_HaxeError(haxe_io_Error.Blocked);
			}
			p += k;
			nbytes -= k;
		}
		return s;
	}
	,readInt32: function() {
		var ch1 = this.readByte();
		var ch2 = this.readByte();
		var ch3 = this.readByte();
		var ch4 = this.readByte();
		if(this.bigEndian) {
			return ch4 | ch3 << 8 | ch2 << 16 | ch1 << 24;
		} else {
			return ch1 | ch2 << 8 | ch3 << 16 | ch4 << 24;
		}
	}
	,readString: function(len,encoding) {
		var b = new haxe_io_Bytes(new ArrayBuffer(len));
		this.readFullBytes(b,0,len);
		return b.getString(0,len,encoding);
	}
	,__class__: haxe_io_Input
	,__properties__: {set_bigEndian:"set_bigEndian"}
};
var _$Sys_FileInput = function(fd) {
	this.fd = fd;
};
$hxClasses["_Sys.FileInput"] = _$Sys_FileInput;
_$Sys_FileInput.__name__ = true;
_$Sys_FileInput.__super__ = haxe_io_Input;
_$Sys_FileInput.prototype = $extend(haxe_io_Input.prototype,{
	readByte: function() {
		var buf = new js_node_buffer_Buffer(1);
		try {
			js_node_Fs.readSync(this.fd,buf,0,1,null);
		} catch( e ) {
			var e1 = (e instanceof js__$Boot_HaxeError) ? e.val : e;
			if(e1.code == "EOF") {
				throw new js__$Boot_HaxeError(new haxe_io_Eof());
			} else {
				throw new js__$Boot_HaxeError(haxe_io_Error.Custom(e1));
			}
		}
		return buf[0];
	}
	,readBytes: function(s,pos,len) {
		var data = s.b;
		var buf = new js_node_buffer_Buffer(data.buffer,data.byteOffset,s.length);
		try {
			return js_node_Fs.readSync(this.fd,buf,pos,len,null);
		} catch( e ) {
			var e1 = (e instanceof js__$Boot_HaxeError) ? e.val : e;
			if(e1.code == "EOF") {
				throw new js__$Boot_HaxeError(new haxe_io_Eof());
			} else {
				throw new js__$Boot_HaxeError(haxe_io_Error.Custom(e1));
			}
		}
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
	,__class__: _$Sys_FileInput
});
var Tilemap = function(inputImage,tileset,tileWidth,tileHeight,inputTileset) {
	this.tiles = [];
	this.inputImage = inputImage;
	this.inputTileset = inputTileset;
	this.tileset = tileset;
	var bytes = js_node_buffer__$Buffer_Helper.bytesOfBuffer(js_node_Fs.readFileSync(inputImage));
	var png = new format_png_Reader(new haxe_io_BytesInput(bytes)).read();
	var header = format_png_Tools.getHeader(png);
	var pngbytes = format_png_Tools.extract32(png);
	var imageWidth = header.width;
	var imageHeight = header.height;
	this.mapWidth = header.width / tileWidth | 0;
	this.mapHeight = header.height / tileHeight | 0;
	var tile = new haxe_io_Bytes(new ArrayBuffer(tileWidth * tileHeight * 4));
	var _g = 0;
	var _g1 = this.mapHeight;
	while(_g < _g1) {
		var my = _g++;
		var _g2 = 0;
		var _g11 = this.mapWidth;
		while(_g2 < _g11) {
			var mx = _g2++;
			var _g3 = 0;
			var _g12 = tileHeight;
			while(_g3 < _g12) {
				var by = _g3++;
				var _g4 = 0;
				var _g13 = tileWidth;
				while(_g4 < _g13) {
					var bx = _g4++;
					var di = (by * tileWidth + bx) * 4;
					var si = ((my * tileHeight + by) * imageWidth + mx * tileWidth + bx) * 4;
					tile.b[di] = pngbytes.b[si];
					tile.b[di + 1] = pngbytes.b[si + 1];
					tile.b[di + 2] = pngbytes.b[si + 2];
					tile.b[di + 3] = pngbytes.b[si + 3];
				}
			}
			var tileString = tile.toHex();
			this.tiles.push(tileset.findTileIndex(tileString));
		}
	}
};
$hxClasses["Tilemap"] = Tilemap;
Tilemap.__name__ = true;
Tilemap.prototype = {
	write: function() {
		var doc = Xml.createDocument();
		var map = Xml.createElement("map");
		map.set("version","1.0");
		map.set("orientation","orthogonal");
		map.set("width","" + this.mapWidth);
		map.set("height","" + this.mapHeight);
		map.set("tilewidth","" + this.tileset.tileWidth);
		map.set("tileheight","" + this.tileset.tileHeight);
		var tileset = Xml.createElement("tileset");
		tileset.set("name","" + this.tileset.name);
		tileset.set("firstgid","1");
		tileset.set("tilewidth","" + this.tileset.tileWidth);
		tileset.set("tileheight","" + this.tileset.tileHeight);
		var image = Xml.createElement("image");
		image.set("source",this.inputTileset);
		var layer = Xml.createElement("layer");
		layer.set("name","background");
		layer.set("width","" + this.mapWidth);
		layer.set("height","" + this.mapHeight);
		var data = Xml.createElement("data");
		data.set("encoding","csv");
		var csv = Xml.createPCData("data");
		var v = this.tiles.join(",");
		if(csv.nodeType == Xml.Document || csv.nodeType == Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, unexpected " + csv.nodeType);
		}
		csv.nodeValue = v;
		doc.addChild(map);
		map.addChild(tileset);
		tileset.addChild(image);
		map.addChild(layer);
		layer.addChild(data);
		data.addChild(csv);
		js_node_Fs.writeFileSync("" + haxe_io_Path.withoutExtension(this.inputImage) + ".tmx",haxe_xml_Printer.print(doc));
	}
	,__class__: Tilemap
};
var Tileset = function(inputTileset,tileWidth,tileHeight) {
	this.tileHeight = 16;
	this.tileWidth = 16;
	this.name = "default";
	this.indexMap = new haxe_ds_StringMap();
	this.tileList = [];
	this.tileWidth = tileWidth;
	this.tileHeight = tileHeight;
	var bytes = js_node_buffer__$Buffer_Helper.bytesOfBuffer(js_node_Fs.readFileSync(inputTileset));
	var png = new format_png_Reader(new haxe_io_BytesInput(bytes)).read();
	var header = format_png_Tools.getHeader(png);
	var pngbytes = format_png_Tools.extract32(png);
	var imageWidth = header.width;
	var imageHeight = header.height;
	var tilesetWidth = header.width / tileWidth | 0;
	var tilesetHeight = header.height / tileHeight | 0;
	var _g = 0;
	var _g1 = tilesetHeight;
	while(_g < _g1) {
		var ty = _g++;
		var _g2 = 0;
		var _g11 = tilesetWidth;
		while(_g2 < _g11) {
			var tx = _g2++;
			var tile = new haxe_io_Bytes(new ArrayBuffer(tileWidth * tileHeight * 4));
			var _g3 = 0;
			var _g12 = tileHeight;
			while(_g3 < _g12) {
				var by = _g3++;
				var _g4 = 0;
				var _g13 = tileWidth;
				while(_g4 < _g13) {
					var bx = _g4++;
					var di = (by * tileWidth + bx) * 4;
					var si = ((ty * tileHeight + by) * imageWidth + tx * tileWidth + bx) * 4;
					tile.b[di] = pngbytes.b[si];
					tile.b[di + 1] = pngbytes.b[si + 1];
					tile.b[di + 2] = pngbytes.b[si + 2];
					tile.b[di + 3] = pngbytes.b[si + 3];
				}
			}
			this.tileList.push(tile);
			var tileString = tile.toHex();
			var _this = this.indexMap;
			if(!(__map_reserved[tileString] != null ? _this.existsReserved(tileString) : _this.h.hasOwnProperty(tileString))) {
				var value = this.tileList.length - 1;
				var _this1 = this.indexMap;
				if(__map_reserved[tileString] != null) {
					_this1.setReserved(tileString,value);
				} else {
					_this1.h[tileString] = value;
				}
			}
		}
	}
};
$hxClasses["Tileset"] = Tileset;
Tileset.__name__ = true;
Tileset.prototype = {
	findTileIndex: function(tile) {
		var _this = this.indexMap;
		var index = __map_reserved[tile] != null ? _this.getReserved(tile) : _this.h[tile];
		if(index == null) {
			return 0;
		} else {
			return index + 1;
		}
	}
	,__class__: Tileset
};
var Xml = function(nodeType) {
	this.nodeType = nodeType;
	this.children = [];
	this.attributeMap = new haxe_ds_StringMap();
};
$hxClasses["Xml"] = Xml;
Xml.__name__ = true;
Xml.createElement = function(name) {
	var xml = new Xml(Xml.Element);
	if(xml.nodeType != Xml.Element) {
		throw new js__$Boot_HaxeError("Bad node type, expected Element but found " + xml.nodeType);
	}
	xml.nodeName = name;
	return xml;
};
Xml.createPCData = function(data) {
	var xml = new Xml(Xml.PCData);
	if(xml.nodeType == Xml.Document || xml.nodeType == Xml.Element) {
		throw new js__$Boot_HaxeError("Bad node type, unexpected " + xml.nodeType);
	}
	xml.nodeValue = data;
	return xml;
};
Xml.createDocument = function() {
	return new Xml(Xml.Document);
};
Xml.prototype = {
	get: function(att) {
		if(this.nodeType != Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, expected Element but found " + this.nodeType);
		}
		var _this = this.attributeMap;
		if(__map_reserved[att] != null) {
			return _this.getReserved(att);
		} else {
			return _this.h[att];
		}
	}
	,set: function(att,value) {
		if(this.nodeType != Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, expected Element but found " + this.nodeType);
		}
		var _this = this.attributeMap;
		if(__map_reserved[att] != null) {
			_this.setReserved(att,value);
		} else {
			_this.h[att] = value;
		}
	}
	,attributes: function() {
		if(this.nodeType != Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, expected Element but found " + this.nodeType);
		}
		return this.attributeMap.keys();
	}
	,addChild: function(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, expected Element or Document but found " + this.nodeType);
		}
		if(x.parent != null) {
			x.parent.removeChild(x);
		}
		this.children.push(x);
		x.parent = this;
	}
	,removeChild: function(x) {
		if(this.nodeType != Xml.Document && this.nodeType != Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, expected Element or Document but found " + this.nodeType);
		}
		if(HxOverrides.remove(this.children,x)) {
			x.parent = null;
			return true;
		}
		return false;
	}
	,toString: function() {
		return haxe_xml_Printer.print(this);
	}
	,__class__: Xml
};
var format_png_Color = $hxEnums["format.png.Color"] = { __ename__ : true, __constructs__ : ["ColGrey","ColTrue","ColIndexed"]
	,ColGrey: ($_=function(alpha) { return {_hx_index:0,alpha:alpha,__enum__:"format.png.Color",toString:$estr}; },$_.__params__ = ["alpha"],$_)
	,ColTrue: ($_=function(alpha) { return {_hx_index:1,alpha:alpha,__enum__:"format.png.Color",toString:$estr}; },$_.__params__ = ["alpha"],$_)
	,ColIndexed: {_hx_index:2,__enum__:"format.png.Color",toString:$estr}
};
format_png_Color.__empty_constructs__ = [format_png_Color.ColIndexed];
var format_png_Chunk = $hxEnums["format.png.Chunk"] = { __ename__ : true, __constructs__ : ["CEnd","CHeader","CData","CPalette","CUnknown"]
	,CEnd: {_hx_index:0,__enum__:"format.png.Chunk",toString:$estr}
	,CHeader: ($_=function(h) { return {_hx_index:1,h:h,__enum__:"format.png.Chunk",toString:$estr}; },$_.__params__ = ["h"],$_)
	,CData: ($_=function(b) { return {_hx_index:2,b:b,__enum__:"format.png.Chunk",toString:$estr}; },$_.__params__ = ["b"],$_)
	,CPalette: ($_=function(b) { return {_hx_index:3,b:b,__enum__:"format.png.Chunk",toString:$estr}; },$_.__params__ = ["b"],$_)
	,CUnknown: ($_=function(id,data) { return {_hx_index:4,id:id,data:data,__enum__:"format.png.Chunk",toString:$estr}; },$_.__params__ = ["id","data"],$_)
};
format_png_Chunk.__empty_constructs__ = [format_png_Chunk.CEnd];
var format_png_Reader = function(i) {
	this.i = i;
	i.set_bigEndian(true);
	this.checkCRC = true;
};
$hxClasses["format.png.Reader"] = format_png_Reader;
format_png_Reader.__name__ = true;
format_png_Reader.prototype = {
	read: function() {
		var b = 137;
		if(this.i.readByte() != b) {
			throw new js__$Boot_HaxeError("Invalid header");
		}
		var b1 = 80;
		if(this.i.readByte() != b1) {
			throw new js__$Boot_HaxeError("Invalid header");
		}
		var b2 = 78;
		if(this.i.readByte() != b2) {
			throw new js__$Boot_HaxeError("Invalid header");
		}
		var b3 = 71;
		if(this.i.readByte() != b3) {
			throw new js__$Boot_HaxeError("Invalid header");
		}
		var b4 = 13;
		if(this.i.readByte() != b4) {
			throw new js__$Boot_HaxeError("Invalid header");
		}
		var b5 = 10;
		if(this.i.readByte() != b5) {
			throw new js__$Boot_HaxeError("Invalid header");
		}
		var b6 = 26;
		if(this.i.readByte() != b6) {
			throw new js__$Boot_HaxeError("Invalid header");
		}
		var b7 = 10;
		if(this.i.readByte() != b7) {
			throw new js__$Boot_HaxeError("Invalid header");
		}
		var l = new haxe_ds_List();
		while(true) {
			var c = this.readChunk();
			l.add(c);
			if(c == format_png_Chunk.CEnd) {
				break;
			}
		}
		return l;
	}
	,readHeader: function(i) {
		i.set_bigEndian(true);
		var width = i.readInt32();
		var height = i.readInt32();
		var colbits = i.readByte();
		var color = i.readByte();
		var color1;
		switch(color) {
		case 0:
			color1 = format_png_Color.ColGrey(false);
			break;
		case 2:
			color1 = format_png_Color.ColTrue(false);
			break;
		case 3:
			color1 = format_png_Color.ColIndexed;
			break;
		case 4:
			color1 = format_png_Color.ColGrey(true);
			break;
		case 6:
			color1 = format_png_Color.ColTrue(true);
			break;
		default:
			throw new js__$Boot_HaxeError("Unknown color model " + color + ":" + colbits);
		}
		var compress = i.readByte();
		var filter = i.readByte();
		if(compress != 0 || filter != 0) {
			throw new js__$Boot_HaxeError("Invalid header");
		}
		var interlace = i.readByte();
		if(interlace != 0 && interlace != 1) {
			throw new js__$Boot_HaxeError("Invalid header");
		}
		return { width : width, height : height, colbits : colbits, color : color1, interlaced : interlace == 1};
	}
	,readChunk: function() {
		var dataLen = this.i.readInt32();
		var id = this.i.readString(4);
		var data = this.i.read(dataLen);
		var crc = this.i.readInt32();
		if(this.checkCRC) {
			var c = new haxe_crypto_Crc32();
			c.byte(HxOverrides.cca(id,0));
			c.byte(HxOverrides.cca(id,1));
			c.byte(HxOverrides.cca(id,2));
			c.byte(HxOverrides.cca(id,3));
			c.update(data,0,data.length);
			if(c.get() != crc) {
				throw new js__$Boot_HaxeError("CRC check failure");
			}
		}
		switch(id) {
		case "IDAT":
			return format_png_Chunk.CData(data);
		case "IEND":
			return format_png_Chunk.CEnd;
		case "IHDR":
			return format_png_Chunk.CHeader(this.readHeader(new haxe_io_BytesInput(data)));
		case "PLTE":
			return format_png_Chunk.CPalette(data);
		default:
			return format_png_Chunk.CUnknown(id,data);
		}
	}
	,__class__: format_png_Reader
};
var format_png_Tools = function() { };
$hxClasses["format.png.Tools"] = format_png_Tools;
format_png_Tools.__name__ = true;
format_png_Tools.getHeader = function(d) {
	var _g_head = d.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var c = val;
		if(c._hx_index == 1) {
			var h = c.h;
			return h;
		}
	}
	throw new js__$Boot_HaxeError("Header not found");
};
format_png_Tools.getPalette = function(d) {
	var _g_head = d.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var c = val;
		if(c._hx_index == 3) {
			var b = c.b;
			return b;
		}
	}
	return null;
};
format_png_Tools.filter = function(data,x,y,stride,prev,p,numChannels) {
	if(numChannels == null) {
		numChannels = 4;
	}
	var b = y == 0 ? 0 : data.b[p - stride];
	var c = x == 0 || y == 0 ? 0 : data.b[p - stride - numChannels];
	var k = prev + b - c;
	var pa = k - prev;
	if(pa < 0) {
		pa = -pa;
	}
	var pb = k - b;
	if(pb < 0) {
		pb = -pb;
	}
	var pc = k - c;
	if(pc < 0) {
		pc = -pc;
	}
	if(pa <= pb && pa <= pc) {
		return prev;
	} else if(pb <= pc) {
		return b;
	} else {
		return c;
	}
};
format_png_Tools.reverseBytes = function(b) {
	var p = 0;
	var _g = 0;
	var _g1 = b.length >> 2;
	while(_g < _g1) {
		var i = _g++;
		var b1 = b.b[p];
		var g = b.b[p + 1];
		var r = b.b[p + 2];
		var a = b.b[p + 3];
		b.b[p++] = a;
		b.b[p++] = r;
		b.b[p++] = g;
		b.b[p++] = b1;
	}
};
format_png_Tools.extractGrey = function(d) {
	var h = format_png_Tools.getHeader(d);
	var grey = new haxe_io_Bytes(new ArrayBuffer(h.width * h.height));
	var data = null;
	var fullData = null;
	var _g_head = d.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var c = val;
		if(c._hx_index == 2) {
			var b = c.b;
			if(fullData != null) {
				fullData.add(b);
			} else if(data == null) {
				data = b;
			} else {
				fullData = new haxe_io_BytesBuffer();
				fullData.add(data);
				fullData.add(b);
				data = null;
			}
		}
	}
	if(fullData != null) {
		data = fullData.getBytes();
	}
	if(data == null) {
		throw new js__$Boot_HaxeError("Data not found");
	}
	data = format_tools_Inflate.run(data);
	var r = 0;
	var w = 0;
	var _g1 = h.color;
	if(_g1._hx_index == 0) {
		var alpha = _g1.alpha;
		if(h.colbits != 8) {
			throw new js__$Boot_HaxeError("Unsupported color mode");
		}
		var width = h.width;
		var stride = (alpha ? 2 : 1) * width + 1;
		if(data.length < h.height * stride) {
			throw new js__$Boot_HaxeError("Not enough data");
		}
		var rinc = alpha ? 2 : 1;
		var _g11 = 0;
		var _g2 = h.height;
		while(_g11 < _g2) {
			var y = _g11++;
			var f = data.b[r++];
			switch(f) {
			case 0:
				var _g12 = 0;
				var _g21 = width;
				while(_g12 < _g21) {
					var x = _g12++;
					var v = data.b[r];
					r += rinc;
					grey.b[w++] = v;
				}
				break;
			case 1:
				var cv = 0;
				var _g13 = 0;
				var _g22 = width;
				while(_g13 < _g22) {
					var x1 = _g13++;
					cv += data.b[r];
					r += rinc;
					grey.b[w++] = cv;
				}
				break;
			case 2:
				var stride1 = y == 0 ? 0 : width;
				var _g14 = 0;
				var _g23 = width;
				while(_g14 < _g23) {
					var x2 = _g14++;
					var v1 = data.b[r] + grey.b[w - stride1];
					r += rinc;
					grey.b[w++] = v1;
				}
				break;
			case 3:
				var cv1 = 0;
				var stride2 = y == 0 ? 0 : width;
				var _g15 = 0;
				var _g24 = width;
				while(_g15 < _g24) {
					var x3 = _g15++;
					cv1 = data.b[r] + (cv1 + grey.b[w - stride2] >> 1) & 255;
					r += rinc;
					grey.b[w++] = cv1;
				}
				break;
			case 4:
				var stride3 = width;
				var cv2 = 0;
				var _g16 = 0;
				var _g25 = width;
				while(_g16 < _g25) {
					var x4 = _g16++;
					var b1 = y == 0 ? 0 : grey.b[w - stride3];
					var c1 = x4 == 0 || y == 0 ? 0 : grey.b[w - stride3 - 1];
					var k = cv2 + b1 - c1;
					var pa = k - cv2;
					if(pa < 0) {
						pa = -pa;
					}
					var pb = k - b1;
					if(pb < 0) {
						pb = -pb;
					}
					var pc = k - c1;
					if(pc < 0) {
						pc = -pc;
					}
					cv2 = (pa <= pb && pa <= pc ? cv2 : pb <= pc ? b1 : c1) + data.b[r] & 255;
					r += rinc;
					grey.b[w++] = cv2;
				}
				break;
			default:
				throw new js__$Boot_HaxeError("Invalid filter " + f);
			}
		}
	} else {
		throw new js__$Boot_HaxeError("Unsupported color mode");
	}
	return grey;
};
format_png_Tools.extract32 = function(d,bytes,flipY) {
	var h = format_png_Tools.getHeader(d);
	var bgra = bytes == null ? new haxe_io_Bytes(new ArrayBuffer(h.width * h.height * 4)) : bytes;
	var data = null;
	var fullData = null;
	var _g_head = d.h;
	while(_g_head != null) {
		var val = _g_head.item;
		_g_head = _g_head.next;
		var c = val;
		if(c._hx_index == 2) {
			var b = c.b;
			if(fullData != null) {
				fullData.add(b);
			} else if(data == null) {
				data = b;
			} else {
				fullData = new haxe_io_BytesBuffer();
				fullData.add(data);
				fullData.add(b);
				data = null;
			}
		}
	}
	if(fullData != null) {
		data = fullData.getBytes();
	}
	if(data == null) {
		throw new js__$Boot_HaxeError("Data not found");
	}
	data = format_tools_Inflate.run(data);
	var r = 0;
	var w = 0;
	var lineDelta = 0;
	if(flipY) {
		lineDelta = -h.width * 8;
		w = (h.height - 1) * (h.width * 4);
	}
	var flipY1 = flipY ? -1 : 1;
	var _g1 = h.color;
	switch(_g1._hx_index) {
	case 0:
		var alpha = _g1.alpha;
		if(h.colbits != 8) {
			throw new js__$Boot_HaxeError("Unsupported color mode");
		}
		var width = h.width;
		var stride = (alpha ? 2 : 1) * width + 1;
		if(data.length < h.height * stride) {
			throw new js__$Boot_HaxeError("Not enough data");
		}
		var alphvaIdx = -1;
		if(!alpha) {
			var _g1_head = d.h;
			while(_g1_head != null) {
				var val1 = _g1_head.item;
				_g1_head = _g1_head.next;
				var t = val1;
				if(t._hx_index == 4 && t.id == "tRNS") {
					var data1 = t.data;
					if(data1.length >= 2) {
						alphvaIdx = data1.b[1];
					}
					break;
				}
			}
		}
		var _g11 = 0;
		var _g2 = h.height;
		while(_g11 < _g2) {
			var y = _g11++;
			var f = data.b[r++];
			switch(f) {
			case 0:
				if(alpha) {
					var _g12 = 0;
					var _g21 = width;
					while(_g12 < _g21) {
						var x = _g12++;
						var v = data.b[r++];
						bgra.b[w++] = v;
						bgra.b[w++] = v;
						bgra.b[w++] = v;
						bgra.b[w++] = data.b[r++];
					}
				} else {
					var _g13 = 0;
					var _g22 = width;
					while(_g13 < _g22) {
						var x1 = _g13++;
						var v1 = data.b[r++];
						bgra.b[w++] = v1;
						bgra.b[w++] = v1;
						bgra.b[w++] = v1;
						bgra.b[w++] = v1 == alphvaIdx ? 0 : 255;
					}
				}
				break;
			case 1:
				var cv = 0;
				var ca = 0;
				if(alpha) {
					var _g14 = 0;
					var _g23 = width;
					while(_g14 < _g23) {
						var x2 = _g14++;
						cv += data.b[r++];
						bgra.b[w++] = cv;
						bgra.b[w++] = cv;
						bgra.b[w++] = cv;
						ca += data.b[r++];
						bgra.b[w++] = ca;
					}
				} else {
					var _g15 = 0;
					var _g24 = width;
					while(_g15 < _g24) {
						var x3 = _g15++;
						cv += data.b[r++];
						bgra.b[w++] = cv;
						bgra.b[w++] = cv;
						bgra.b[w++] = cv;
						bgra.b[w++] = cv == alphvaIdx ? 0 : 255;
					}
				}
				break;
			case 2:
				var stride1 = y == 0 ? 0 : width * 4 * flipY1;
				if(alpha) {
					var _g16 = 0;
					var _g25 = width;
					while(_g16 < _g25) {
						var x4 = _g16++;
						var v2 = data.b[r++] + bgra.b[w - stride1];
						bgra.b[w++] = v2;
						bgra.b[w++] = v2;
						bgra.b[w++] = v2;
						bgra.b[w++] = data.b[r++] + bgra.b[w - stride1];
					}
				} else {
					var _g17 = 0;
					var _g26 = width;
					while(_g17 < _g26) {
						var x5 = _g17++;
						var v3 = data.b[r++] + bgra.b[w - stride1];
						bgra.b[w++] = v3;
						bgra.b[w++] = v3;
						bgra.b[w++] = v3;
						bgra.b[w++] = v3 == alphvaIdx ? 0 : 255;
					}
				}
				break;
			case 3:
				var cv1 = 0;
				var ca1 = 0;
				var stride2 = y == 0 ? 0 : width * 4 * flipY1;
				if(alpha) {
					var _g18 = 0;
					var _g27 = width;
					while(_g18 < _g27) {
						var x6 = _g18++;
						cv1 = data.b[r++] + (cv1 + bgra.b[w - stride2] >> 1) & 255;
						bgra.b[w++] = cv1;
						bgra.b[w++] = cv1;
						bgra.b[w++] = cv1;
						ca1 = data.b[r++] + (ca1 + bgra.b[w - stride2] >> 1) & 255;
						bgra.b[w++] = ca1;
					}
				} else {
					var _g19 = 0;
					var _g28 = width;
					while(_g19 < _g28) {
						var x7 = _g19++;
						cv1 = data.b[r++] + (cv1 + bgra.b[w - stride2] >> 1) & 255;
						bgra.b[w++] = cv1;
						bgra.b[w++] = cv1;
						bgra.b[w++] = cv1;
						bgra.b[w++] = cv1 == alphvaIdx ? 0 : 255;
					}
				}
				break;
			case 4:
				var stride3 = width * 4 * flipY1;
				var cv2 = 0;
				var ca2 = 0;
				if(alpha) {
					var _g110 = 0;
					var _g29 = width;
					while(_g110 < _g29) {
						var x8 = _g110++;
						var b1 = y == 0 ? 0 : bgra.b[w - stride3];
						var c1 = x8 == 0 || y == 0 ? 0 : bgra.b[w - stride3 - 4];
						var k = cv2 + b1 - c1;
						var pa = k - cv2;
						if(pa < 0) {
							pa = -pa;
						}
						var pb = k - b1;
						if(pb < 0) {
							pb = -pb;
						}
						var pc = k - c1;
						if(pc < 0) {
							pc = -pc;
						}
						var pos = r++;
						cv2 = (pa <= pb && pa <= pc ? cv2 : pb <= pc ? b1 : c1) + data.b[pos] & 255;
						bgra.b[w++] = cv2;
						bgra.b[w++] = cv2;
						bgra.b[w++] = cv2;
						var b2 = y == 0 ? 0 : bgra.b[w - stride3];
						var c2 = x8 == 0 || y == 0 ? 0 : bgra.b[w - stride3 - 4];
						var k1 = ca2 + b2 - c2;
						var pa1 = k1 - ca2;
						if(pa1 < 0) {
							pa1 = -pa1;
						}
						var pb1 = k1 - b2;
						if(pb1 < 0) {
							pb1 = -pb1;
						}
						var pc1 = k1 - c2;
						if(pc1 < 0) {
							pc1 = -pc1;
						}
						var pos1 = r++;
						ca2 = (pa1 <= pb1 && pa1 <= pc1 ? ca2 : pb1 <= pc1 ? b2 : c2) + data.b[pos1] & 255;
						bgra.b[w++] = ca2;
					}
				} else {
					var _g111 = 0;
					var _g210 = width;
					while(_g111 < _g210) {
						var x9 = _g111++;
						var b3 = y == 0 ? 0 : bgra.b[w - stride3];
						var c3 = x9 == 0 || y == 0 ? 0 : bgra.b[w - stride3 - 4];
						var k2 = cv2 + b3 - c3;
						var pa2 = k2 - cv2;
						if(pa2 < 0) {
							pa2 = -pa2;
						}
						var pb2 = k2 - b3;
						if(pb2 < 0) {
							pb2 = -pb2;
						}
						var pc2 = k2 - c3;
						if(pc2 < 0) {
							pc2 = -pc2;
						}
						var pos2 = r++;
						cv2 = (pa2 <= pb2 && pa2 <= pc2 ? cv2 : pb2 <= pc2 ? b3 : c3) + data.b[pos2] & 255;
						bgra.b[w++] = cv2;
						bgra.b[w++] = cv2;
						bgra.b[w++] = cv2;
						bgra.b[w++] = cv2 == alphvaIdx ? 0 : 255;
					}
				}
				break;
			default:
				throw new js__$Boot_HaxeError("Invalid filter " + f);
			}
			w += lineDelta;
		}
		break;
	case 1:
		var alpha1 = _g1.alpha;
		if(h.colbits != 8) {
			throw new js__$Boot_HaxeError("Unsupported color mode");
		}
		var width1 = h.width;
		var stride4 = (alpha1 ? 4 : 3) * width1 + 1;
		if(data.length < h.height * stride4) {
			throw new js__$Boot_HaxeError("Not enough data");
		}
		var alphaRed = -1;
		var alphaGreen = -1;
		var alphaBlue = -1;
		if(!alpha1) {
			var _g1_head1 = d.h;
			while(_g1_head1 != null) {
				var val2 = _g1_head1.item;
				_g1_head1 = _g1_head1.next;
				var t1 = val2;
				if(t1._hx_index == 4 && t1.id == "tRNS") {
					var data2 = t1.data;
					if(data2.length >= 6) {
						alphaRed = data2.b[1];
						alphaGreen = data2.b[3];
						alphaBlue = data2.b[5];
					}
					break;
				}
			}
		}
		var cr = 0;
		var cg = 0;
		var cb = 0;
		var ca3 = 0;
		var _g112 = 0;
		var _g211 = h.height;
		while(_g112 < _g211) {
			var y1 = _g112++;
			var f1 = data.b[r++];
			switch(f1) {
			case 0:
				if(alpha1) {
					var _g113 = 0;
					var _g212 = width1;
					while(_g113 < _g212) {
						var x10 = _g113++;
						bgra.b[w++] = data.b[r + 2];
						bgra.b[w++] = data.b[r + 1];
						bgra.b[w++] = data.b[r];
						bgra.b[w++] = data.b[r + 3];
						r += 4;
					}
				} else {
					var _g114 = 0;
					var _g213 = width1;
					while(_g114 < _g213) {
						var x11 = _g114++;
						cb = data.b[r + 2];
						bgra.b[w++] = cb;
						cg = data.b[r + 1];
						bgra.b[w++] = cg;
						cr = data.b[r];
						bgra.b[w++] = cr;
						bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
						r += 3;
					}
				}
				break;
			case 1:
				ca3 = 0;
				cb = ca3;
				cg = cb;
				cr = cg;
				if(alpha1) {
					var _g115 = 0;
					var _g214 = width1;
					while(_g115 < _g214) {
						var x12 = _g115++;
						cb += data.b[r + 2];
						bgra.b[w++] = cb;
						cg += data.b[r + 1];
						bgra.b[w++] = cg;
						cr += data.b[r];
						bgra.b[w++] = cr;
						ca3 += data.b[r + 3];
						bgra.b[w++] = ca3;
						r += 4;
					}
				} else {
					var _g116 = 0;
					var _g215 = width1;
					while(_g116 < _g215) {
						var x13 = _g116++;
						cb += data.b[r + 2];
						bgra.b[w++] = cb;
						cg += data.b[r + 1];
						bgra.b[w++] = cg;
						cr += data.b[r];
						bgra.b[w++] = cr;
						bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
						r += 3;
					}
				}
				break;
			case 2:
				var stride5 = y1 == 0 ? 0 : width1 * 4 * flipY1;
				if(alpha1) {
					var _g117 = 0;
					var _g216 = width1;
					while(_g117 < _g216) {
						var x14 = _g117++;
						bgra.b[w] = data.b[r + 2] + bgra.b[w - stride5];
						++w;
						bgra.b[w] = data.b[r + 1] + bgra.b[w - stride5];
						++w;
						bgra.b[w] = data.b[r] + bgra.b[w - stride5];
						++w;
						bgra.b[w] = data.b[r + 3] + bgra.b[w - stride5];
						++w;
						r += 4;
					}
				} else {
					var _g118 = 0;
					var _g217 = width1;
					while(_g118 < _g217) {
						var x15 = _g118++;
						cb = data.b[r + 2] + bgra.b[w - stride5];
						bgra.b[w] = cb;
						++w;
						cg = data.b[r + 1] + bgra.b[w - stride5];
						bgra.b[w] = cg;
						++w;
						cr = data.b[r] + bgra.b[w - stride5];
						bgra.b[w] = cr;
						++w;
						bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
						r += 3;
					}
				}
				break;
			case 3:
				ca3 = 0;
				cb = ca3;
				cg = cb;
				cr = cg;
				var stride6 = y1 == 0 ? 0 : width1 * 4 * flipY1;
				if(alpha1) {
					var _g119 = 0;
					var _g218 = width1;
					while(_g119 < _g218) {
						var x16 = _g119++;
						cb = data.b[r + 2] + (cb + bgra.b[w - stride6] >> 1) & 255;
						bgra.b[w++] = cb;
						cg = data.b[r + 1] + (cg + bgra.b[w - stride6] >> 1) & 255;
						bgra.b[w++] = cg;
						cr = data.b[r] + (cr + bgra.b[w - stride6] >> 1) & 255;
						bgra.b[w++] = cr;
						ca3 = data.b[r + 3] + (ca3 + bgra.b[w - stride6] >> 1) & 255;
						bgra.b[w++] = ca3;
						r += 4;
					}
				} else {
					var _g120 = 0;
					var _g219 = width1;
					while(_g120 < _g219) {
						var x17 = _g120++;
						cb = data.b[r + 2] + (cb + bgra.b[w - stride6] >> 1) & 255;
						bgra.b[w++] = cb;
						cg = data.b[r + 1] + (cg + bgra.b[w - stride6] >> 1) & 255;
						bgra.b[w++] = cg;
						cr = data.b[r] + (cr + bgra.b[w - stride6] >> 1) & 255;
						bgra.b[w++] = cr;
						bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
						r += 3;
					}
				}
				break;
			case 4:
				var stride7 = width1 * 4 * flipY1;
				ca3 = 0;
				cb = ca3;
				cg = cb;
				cr = cg;
				if(alpha1) {
					var _g121 = 0;
					var _g220 = width1;
					while(_g121 < _g220) {
						var x18 = _g121++;
						var b4 = y1 == 0 ? 0 : bgra.b[w - stride7];
						var c4 = x18 == 0 || y1 == 0 ? 0 : bgra.b[w - stride7 - 4];
						var k3 = cb + b4 - c4;
						var pa3 = k3 - cb;
						if(pa3 < 0) {
							pa3 = -pa3;
						}
						var pb3 = k3 - b4;
						if(pb3 < 0) {
							pb3 = -pb3;
						}
						var pc3 = k3 - c4;
						if(pc3 < 0) {
							pc3 = -pc3;
						}
						cb = (pa3 <= pb3 && pa3 <= pc3 ? cb : pb3 <= pc3 ? b4 : c4) + data.b[r + 2] & 255;
						bgra.b[w++] = cb;
						var b5 = y1 == 0 ? 0 : bgra.b[w - stride7];
						var c5 = x18 == 0 || y1 == 0 ? 0 : bgra.b[w - stride7 - 4];
						var k4 = cg + b5 - c5;
						var pa4 = k4 - cg;
						if(pa4 < 0) {
							pa4 = -pa4;
						}
						var pb4 = k4 - b5;
						if(pb4 < 0) {
							pb4 = -pb4;
						}
						var pc4 = k4 - c5;
						if(pc4 < 0) {
							pc4 = -pc4;
						}
						cg = (pa4 <= pb4 && pa4 <= pc4 ? cg : pb4 <= pc4 ? b5 : c5) + data.b[r + 1] & 255;
						bgra.b[w++] = cg;
						var b6 = y1 == 0 ? 0 : bgra.b[w - stride7];
						var c6 = x18 == 0 || y1 == 0 ? 0 : bgra.b[w - stride7 - 4];
						var k5 = cr + b6 - c6;
						var pa5 = k5 - cr;
						if(pa5 < 0) {
							pa5 = -pa5;
						}
						var pb5 = k5 - b6;
						if(pb5 < 0) {
							pb5 = -pb5;
						}
						var pc5 = k5 - c6;
						if(pc5 < 0) {
							pc5 = -pc5;
						}
						cr = (pa5 <= pb5 && pa5 <= pc5 ? cr : pb5 <= pc5 ? b6 : c6) + data.b[r] & 255;
						bgra.b[w++] = cr;
						var b7 = y1 == 0 ? 0 : bgra.b[w - stride7];
						var c7 = x18 == 0 || y1 == 0 ? 0 : bgra.b[w - stride7 - 4];
						var k6 = ca3 + b7 - c7;
						var pa6 = k6 - ca3;
						if(pa6 < 0) {
							pa6 = -pa6;
						}
						var pb6 = k6 - b7;
						if(pb6 < 0) {
							pb6 = -pb6;
						}
						var pc6 = k6 - c7;
						if(pc6 < 0) {
							pc6 = -pc6;
						}
						ca3 = (pa6 <= pb6 && pa6 <= pc6 ? ca3 : pb6 <= pc6 ? b7 : c7) + data.b[r + 3] & 255;
						bgra.b[w++] = ca3;
						r += 4;
					}
				} else {
					var _g122 = 0;
					var _g221 = width1;
					while(_g122 < _g221) {
						var x19 = _g122++;
						var b8 = y1 == 0 ? 0 : bgra.b[w - stride7];
						var c8 = x19 == 0 || y1 == 0 ? 0 : bgra.b[w - stride7 - 4];
						var k7 = cb + b8 - c8;
						var pa7 = k7 - cb;
						if(pa7 < 0) {
							pa7 = -pa7;
						}
						var pb7 = k7 - b8;
						if(pb7 < 0) {
							pb7 = -pb7;
						}
						var pc7 = k7 - c8;
						if(pc7 < 0) {
							pc7 = -pc7;
						}
						cb = (pa7 <= pb7 && pa7 <= pc7 ? cb : pb7 <= pc7 ? b8 : c8) + data.b[r + 2] & 255;
						bgra.b[w++] = cb;
						var b9 = y1 == 0 ? 0 : bgra.b[w - stride7];
						var c9 = x19 == 0 || y1 == 0 ? 0 : bgra.b[w - stride7 - 4];
						var k8 = cg + b9 - c9;
						var pa8 = k8 - cg;
						if(pa8 < 0) {
							pa8 = -pa8;
						}
						var pb8 = k8 - b9;
						if(pb8 < 0) {
							pb8 = -pb8;
						}
						var pc8 = k8 - c9;
						if(pc8 < 0) {
							pc8 = -pc8;
						}
						cg = (pa8 <= pb8 && pa8 <= pc8 ? cg : pb8 <= pc8 ? b9 : c9) + data.b[r + 1] & 255;
						bgra.b[w++] = cg;
						var b10 = y1 == 0 ? 0 : bgra.b[w - stride7];
						var c10 = x19 == 0 || y1 == 0 ? 0 : bgra.b[w - stride7 - 4];
						var k9 = cr + b10 - c10;
						var pa9 = k9 - cr;
						if(pa9 < 0) {
							pa9 = -pa9;
						}
						var pb9 = k9 - b10;
						if(pb9 < 0) {
							pb9 = -pb9;
						}
						var pc9 = k9 - c10;
						if(pc9 < 0) {
							pc9 = -pc9;
						}
						cr = (pa9 <= pb9 && pa9 <= pc9 ? cr : pb9 <= pc9 ? b10 : c10) + data.b[r] & 255;
						bgra.b[w++] = cr;
						bgra.b[w++] = cr == alphaRed && cg == alphaGreen && cb == alphaBlue ? 0 : 255;
						r += 3;
					}
				}
				break;
			default:
				throw new js__$Boot_HaxeError("Invalid filter " + f1);
			}
			w += lineDelta;
		}
		break;
	case 2:
		var pal = format_png_Tools.getPalette(d);
		if(pal == null) {
			throw new js__$Boot_HaxeError("PNG Palette is missing");
		}
		var alpha2 = null;
		var _g1_head2 = d.h;
		while(_g1_head2 != null) {
			var val3 = _g1_head2.item;
			_g1_head2 = _g1_head2.next;
			var t2 = val3;
			if(t2._hx_index == 4 && t2.id == "tRNS") {
				var data3 = t2.data;
				alpha2 = data3;
				break;
			}
		}
		if(alpha2 != null && alpha2.length < 1 << h.colbits) {
			var alpha21 = new haxe_io_Bytes(new ArrayBuffer(1 << h.colbits));
			alpha21.blit(0,alpha2,0,alpha2.length);
			alpha21.fill(alpha2.length,alpha21.length - alpha2.length,255);
			alpha2 = alpha21;
		}
		var width2 = h.width;
		var stride8 = Math.ceil(width2 * h.colbits / 8) + 1;
		if(data.length < h.height * stride8) {
			throw new js__$Boot_HaxeError("Not enough data");
		}
		var tmp = h.width * h.colbits;
		var rline = tmp >> 3;
		var _g222 = 0;
		var _g3 = h.height;
		while(_g222 < _g3) {
			var y2 = _g222++;
			var f2 = data.b[r++];
			if(f2 == 0) {
				r += rline;
				continue;
			}
			switch(f2) {
			case 1:
				var c11 = 0;
				var _g223 = 0;
				var _g31 = width2;
				while(_g223 < _g31) {
					var x20 = _g223++;
					var v4 = data.b[r];
					c11 += v4;
					data.b[r++] = c11 & 255;
				}
				break;
			case 2:
				var stride9 = y2 == 0 ? 0 : rline + 1;
				var _g224 = 0;
				var _g32 = width2;
				while(_g224 < _g32) {
					var x21 = _g224++;
					var v5 = data.b[r];
					data.b[r] = v5 + data.b[r - stride9];
					++r;
				}
				break;
			case 3:
				var c12 = 0;
				var stride10 = y2 == 0 ? 0 : rline + 1;
				var _g225 = 0;
				var _g33 = width2;
				while(_g225 < _g33) {
					var x22 = _g225++;
					var v6 = data.b[r];
					c12 = v6 + (c12 + data.b[r - stride10] >> 1) & 255;
					data.b[r++] = c12;
				}
				break;
			case 4:
				var stride11 = rline + 1;
				var c13 = 0;
				var _g226 = 0;
				var _g34 = width2;
				while(_g226 < _g34) {
					var x23 = _g226++;
					var v7 = data.b[r];
					var b11 = y2 == 0 ? 0 : data.b[r - stride11];
					var c14 = x23 == 0 || y2 == 0 ? 0 : data.b[r - stride11 - 1];
					var k10 = c13 + b11 - c14;
					var pa10 = k10 - c13;
					if(pa10 < 0) {
						pa10 = -pa10;
					}
					var pb10 = k10 - b11;
					if(pb10 < 0) {
						pb10 = -pb10;
					}
					var pc10 = k10 - c14;
					if(pc10 < 0) {
						pc10 = -pc10;
					}
					c13 = (pa10 <= pb10 && pa10 <= pc10 ? c13 : pb10 <= pc10 ? b11 : c14) + v7 & 255;
					data.b[r++] = c13;
				}
				break;
			default:
				throw new js__$Boot_HaxeError("Invalid filter " + f2);
			}
		}
		var r1 = 0;
		if(h.colbits == 8) {
			var _g4 = 0;
			var _g5 = h.height;
			while(_g4 < _g5) {
				var y3 = _g4++;
				++r1;
				var _g41 = 0;
				var _g51 = h.width;
				while(_g41 < _g51) {
					var x24 = _g41++;
					var c15 = data.b[r1++];
					bgra.b[w++] = pal.b[c15 * 3 + 2];
					bgra.b[w++] = pal.b[c15 * 3 + 1];
					bgra.b[w++] = pal.b[c15 * 3];
					bgra.b[w++] = alpha2 != null ? alpha2.b[c15] : 255;
				}
				w += lineDelta;
			}
		} else if(h.colbits < 8) {
			var req = h.colbits;
			var mask = (1 << req) - 1;
			var _g42 = 0;
			var _g52 = h.height;
			while(_g42 < _g52) {
				var y4 = _g42++;
				++r1;
				var bits = 0;
				var nbits = 0;
				var _g43 = 0;
				var _g53 = h.width;
				while(_g43 < _g53) {
					var x25 = _g43++;
					if(nbits < req) {
						bits = bits << 8 | data.b[r1++];
						nbits += 8;
					}
					var c16 = bits >>> nbits - req & mask;
					nbits -= req;
					bgra.b[w++] = pal.b[c16 * 3 + 2];
					bgra.b[w++] = pal.b[c16 * 3 + 1];
					bgra.b[w++] = pal.b[c16 * 3];
					bgra.b[w++] = alpha2 != null ? alpha2.b[c16] : 255;
				}
				w += lineDelta;
			}
		} else {
			throw new js__$Boot_HaxeError(h.colbits + " indexed bits per pixel not supported");
		}
		break;
	}
	return bgra;
};
format_png_Tools.buildGrey = function(width,height,data,level) {
	if(level == null) {
		level = 9;
	}
	var rgb = new haxe_io_Bytes(new ArrayBuffer(width * height + height));
	var w = 0;
	var r = 0;
	var _g = 0;
	var _g1 = height;
	while(_g < _g1) {
		var y = _g++;
		rgb.b[w++] = 0;
		var _g2 = 0;
		var _g11 = width;
		while(_g2 < _g11) {
			var x = _g2++;
			rgb.b[w++] = data.b[r++];
		}
	}
	var l = new haxe_ds_List();
	l.add(format_png_Chunk.CHeader({ width : width, height : height, colbits : 8, color : format_png_Color.ColGrey(false), interlaced : false}));
	l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgb,level)));
	l.add(format_png_Chunk.CEnd);
	return l;
};
format_png_Tools.buildRGB = function(width,height,data,level) {
	if(level == null) {
		level = 9;
	}
	var rgb = new haxe_io_Bytes(new ArrayBuffer(width * height * 3 + height));
	var w = 0;
	var r = 0;
	var _g = 0;
	var _g1 = height;
	while(_g < _g1) {
		var y = _g++;
		rgb.b[w++] = 0;
		var _g2 = 0;
		var _g11 = width;
		while(_g2 < _g11) {
			var x = _g2++;
			rgb.b[w++] = data.b[r + 2];
			rgb.b[w++] = data.b[r + 1];
			rgb.b[w++] = data.b[r];
			r += 3;
		}
	}
	var l = new haxe_ds_List();
	l.add(format_png_Chunk.CHeader({ width : width, height : height, colbits : 8, color : format_png_Color.ColTrue(false), interlaced : false}));
	l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgb,level)));
	l.add(format_png_Chunk.CEnd);
	return l;
};
format_png_Tools.build32ARGB = function(width,height,data,level) {
	if(level == null) {
		level = 9;
	}
	var rgba = new haxe_io_Bytes(new ArrayBuffer(width * height * 4 + height));
	var w = 0;
	var r = 0;
	var _g = 0;
	var _g1 = height;
	while(_g < _g1) {
		var y = _g++;
		rgba.b[w++] = 0;
		var _g2 = 0;
		var _g11 = width;
		while(_g2 < _g11) {
			var x = _g2++;
			rgba.b[w++] = data.b[r + 1];
			rgba.b[w++] = data.b[r + 2];
			rgba.b[w++] = data.b[r + 3];
			rgba.b[w++] = data.b[r];
			r += 4;
		}
	}
	var l = new haxe_ds_List();
	l.add(format_png_Chunk.CHeader({ width : width, height : height, colbits : 8, color : format_png_Color.ColTrue(true), interlaced : false}));
	l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgba,level)));
	l.add(format_png_Chunk.CEnd);
	return l;
};
format_png_Tools.build32BGRA = function(width,height,data,level) {
	if(level == null) {
		level = 9;
	}
	var rgba = new haxe_io_Bytes(new ArrayBuffer(width * height * 4 + height));
	var w = 0;
	var r = 0;
	var _g = 0;
	var _g1 = height;
	while(_g < _g1) {
		var y = _g++;
		rgba.b[w++] = 0;
		var _g2 = 0;
		var _g11 = width;
		while(_g2 < _g11) {
			var x = _g2++;
			rgba.b[w++] = data.b[r + 2];
			rgba.b[w++] = data.b[r + 1];
			rgba.b[w++] = data.b[r];
			rgba.b[w++] = data.b[r + 3];
			r += 4;
		}
	}
	var l = new haxe_ds_List();
	l.add(format_png_Chunk.CHeader({ width : width, height : height, colbits : 8, color : format_png_Color.ColTrue(true), interlaced : false}));
	l.add(format_png_Chunk.CData(format_tools_Deflate.run(rgba,level)));
	l.add(format_png_Chunk.CEnd);
	return l;
};
var format_tools_Deflate = function() { };
$hxClasses["format.tools.Deflate"] = format_tools_Deflate;
format_tools_Deflate.__name__ = true;
format_tools_Deflate.run = function(b,level) {
	if(level == null) {
		level = 9;
	}
	return haxe_zip_Compress.run(b,level);
};
var format_tools_Inflate = function() { };
$hxClasses["format.tools.Inflate"] = format_tools_Inflate;
format_tools_Inflate.__name__ = true;
format_tools_Inflate.run = function(bytes) {
	return haxe_zip_Uncompress.run(bytes);
};
var haxe_IMap = function() { };
$hxClasses["haxe.IMap"] = haxe_IMap;
haxe_IMap.__name__ = true;
haxe_IMap.prototype = {
	__class__: haxe_IMap
};
var haxe_Log = function() { };
$hxClasses["haxe.Log"] = haxe_Log;
haxe_Log.__name__ = true;
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos != null && infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v1 = _g1[_g];
			++_g;
			str += ", " + Std.string(v1);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_crypto_Crc32 = function() {
	this.crc = -1;
};
$hxClasses["haxe.crypto.Crc32"] = haxe_crypto_Crc32;
haxe_crypto_Crc32.__name__ = true;
haxe_crypto_Crc32.prototype = {
	byte: function(b) {
		var tmp = (this.crc ^ b) & 255;
		if((tmp & 1) == 1) {
			tmp = tmp >>> 1 ^ -306674912;
		} else {
			tmp >>>= 1;
		}
		if((tmp & 1) == 1) {
			tmp = tmp >>> 1 ^ -306674912;
		} else {
			tmp >>>= 1;
		}
		if((tmp & 1) == 1) {
			tmp = tmp >>> 1 ^ -306674912;
		} else {
			tmp >>>= 1;
		}
		if((tmp & 1) == 1) {
			tmp = tmp >>> 1 ^ -306674912;
		} else {
			tmp >>>= 1;
		}
		if((tmp & 1) == 1) {
			tmp = tmp >>> 1 ^ -306674912;
		} else {
			tmp >>>= 1;
		}
		if((tmp & 1) == 1) {
			tmp = tmp >>> 1 ^ -306674912;
		} else {
			tmp >>>= 1;
		}
		if((tmp & 1) == 1) {
			tmp = tmp >>> 1 ^ -306674912;
		} else {
			tmp >>>= 1;
		}
		if((tmp & 1) == 1) {
			tmp = tmp >>> 1 ^ -306674912;
		} else {
			tmp >>>= 1;
		}
		this.crc = this.crc >>> 8 ^ tmp;
	}
	,update: function(b,pos,len) {
		var b1 = b.b.bufferValue;
		var _g = pos;
		var _g1 = pos + len;
		while(_g < _g1) {
			var i = _g++;
			var tmp = (this.crc ^ b1.bytes[i]) & 255;
			if((tmp & 1) == 1) {
				tmp = tmp >>> 1 ^ -306674912;
			} else {
				tmp >>>= 1;
			}
			if((tmp & 1) == 1) {
				tmp = tmp >>> 1 ^ -306674912;
			} else {
				tmp >>>= 1;
			}
			if((tmp & 1) == 1) {
				tmp = tmp >>> 1 ^ -306674912;
			} else {
				tmp >>>= 1;
			}
			if((tmp & 1) == 1) {
				tmp = tmp >>> 1 ^ -306674912;
			} else {
				tmp >>>= 1;
			}
			if((tmp & 1) == 1) {
				tmp = tmp >>> 1 ^ -306674912;
			} else {
				tmp >>>= 1;
			}
			if((tmp & 1) == 1) {
				tmp = tmp >>> 1 ^ -306674912;
			} else {
				tmp >>>= 1;
			}
			if((tmp & 1) == 1) {
				tmp = tmp >>> 1 ^ -306674912;
			} else {
				tmp >>>= 1;
			}
			if((tmp & 1) == 1) {
				tmp = tmp >>> 1 ^ -306674912;
			} else {
				tmp >>>= 1;
			}
			this.crc = this.crc >>> 8 ^ tmp;
		}
	}
	,get: function() {
		return this.crc ^ -1;
	}
	,__class__: haxe_crypto_Crc32
};
var haxe_ds_List = function() {
	this.length = 0;
};
$hxClasses["haxe.ds.List"] = haxe_ds_List;
haxe_ds_List.__name__ = true;
haxe_ds_List.prototype = {
	add: function(item) {
		var x = new haxe_ds__$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
	,__class__: haxe_ds_List
};
var haxe_ds__$List_ListNode = function(item,next) {
	this.item = item;
	this.next = next;
};
$hxClasses["haxe.ds._List.ListNode"] = haxe_ds__$List_ListNode;
haxe_ds__$List_ListNode.__name__ = true;
haxe_ds__$List_ListNode.prototype = {
	__class__: haxe_ds__$List_ListNode
};
var haxe_ds_StringMap = function() {
	this.h = { };
};
$hxClasses["haxe.ds.StringMap"] = haxe_ds_StringMap;
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	set: function(key,value) {
		if(__map_reserved[key] != null) {
			this.setReserved(key,value);
		} else {
			this.h[key] = value;
		}
	}
	,get: function(key) {
		if(__map_reserved[key] != null) {
			return this.getReserved(key);
		}
		return this.h[key];
	}
	,setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
	,existsReserved: function(key) {
		if(this.rh == null) {
			return false;
		}
		return this.rh.hasOwnProperty("$" + key);
	}
	,keys: function() {
		return HxOverrides.iter(this.arrayKeys());
	}
	,arrayKeys: function() {
		var out = [];
		for( var key in this.h ) {
		if(this.h.hasOwnProperty(key)) {
			out.push(key);
		}
		}
		if(this.rh != null) {
			for( var key in this.rh ) {
			if(key.charCodeAt(0) == 36) {
				out.push(key.substr(1));
			}
			}
		}
		return out;
	}
	,__class__: haxe_ds_StringMap
};
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
$hxClasses["haxe.io.Bytes"] = haxe_io_Bytes;
haxe_io_Bytes.__name__ = true;
haxe_io_Bytes.prototype = {
	blit: function(pos,src,srcpos,len) {
		if(pos < 0 || srcpos < 0 || len < 0 || pos + len > this.length || srcpos + len > src.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		if(srcpos == 0 && len == src.b.byteLength) {
			this.b.set(src.b,pos);
		} else {
			this.b.set(src.b.subarray(srcpos,srcpos + len),pos);
		}
	}
	,fill: function(pos,len,value) {
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			this.b[pos++] = value;
		}
	}
	,getString: function(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		var s = "";
		var b = this.b;
		var i = pos;
		var max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			var debug = pos > 0;
			while(i < max) {
				var c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					var code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					var c2 = b[i++];
					var code1 = (c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code1);
				} else {
					var c21 = b[i++];
					var c3 = b[i++];
					var u = (c & 15) << 18 | (c21 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				var c1 = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c1);
			}
			break;
		}
		return s;
	}
	,toHex: function() {
		var s_b = "";
		var chars = [];
		var str = "0123456789abcdef";
		var _g = 0;
		var _g1 = str.length;
		while(_g < _g1) {
			var i = _g++;
			chars.push(HxOverrides.cca(str,i));
		}
		var _g2 = 0;
		var _g3 = this.length;
		while(_g2 < _g3) {
			var i1 = _g2++;
			var c = this.b[i1];
			s_b += String.fromCodePoint(chars[c >> 4]);
			s_b += String.fromCodePoint(chars[c & 15]);
		}
		return s_b;
	}
	,__class__: haxe_io_Bytes
};
var haxe_io_BytesBuffer = function() {
	this.pos = 0;
	this.size = 0;
};
$hxClasses["haxe.io.BytesBuffer"] = haxe_io_BytesBuffer;
haxe_io_BytesBuffer.__name__ = true;
haxe_io_BytesBuffer.prototype = {
	add: function(src) {
		if(this.pos + src.length > this.size) {
			this.grow(src.length);
		}
		if(this.size == 0) {
			return;
		}
		var sub = new Uint8Array(src.b.buffer,src.b.byteOffset,src.length);
		this.u8.set(sub,this.pos);
		this.pos += src.length;
	}
	,grow: function(delta) {
		var req = this.pos + delta;
		var nsize = this.size == 0 ? 16 : this.size;
		while(nsize < req) nsize = nsize * 3 >> 1;
		var nbuf = new ArrayBuffer(nsize);
		var nu8 = new Uint8Array(nbuf);
		if(this.size > 0) {
			nu8.set(this.u8);
		}
		this.size = nsize;
		this.buffer = nbuf;
		this.u8 = nu8;
		this.view = new DataView(this.buffer);
	}
	,getBytes: function() {
		if(this.size == 0) {
			return new haxe_io_Bytes(new ArrayBuffer(0));
		}
		var b = new haxe_io_Bytes(this.buffer);
		b.length = this.pos;
		return b;
	}
	,__class__: haxe_io_BytesBuffer
};
var haxe_io_BytesInput = function(b,pos,len) {
	if(pos == null) {
		pos = 0;
	}
	if(len == null) {
		len = b.length - pos;
	}
	if(pos < 0 || len < 0 || pos + len > b.length) {
		throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
	}
	this.b = b.b;
	this.pos = pos;
	this.len = len;
	this.totlen = len;
};
$hxClasses["haxe.io.BytesInput"] = haxe_io_BytesInput;
haxe_io_BytesInput.__name__ = true;
haxe_io_BytesInput.__super__ = haxe_io_Input;
haxe_io_BytesInput.prototype = $extend(haxe_io_Input.prototype,{
	readByte: function() {
		if(this.len == 0) {
			throw new js__$Boot_HaxeError(new haxe_io_Eof());
		}
		this.len--;
		return this.b[this.pos++];
	}
	,readBytes: function(buf,pos,len) {
		if(pos < 0 || len < 0 || pos + len > buf.length) {
			throw new js__$Boot_HaxeError(haxe_io_Error.OutsideBounds);
		}
		if(this.len == 0 && len > 0) {
			throw new js__$Boot_HaxeError(new haxe_io_Eof());
		}
		if(this.len < len) {
			len = this.len;
		}
		var b1 = this.b;
		var b2 = buf.b;
		var _g = 0;
		var _g1 = len;
		while(_g < _g1) {
			var i = _g++;
			b2[pos + i] = b1[this.pos + i];
		}
		this.pos += len;
		this.len -= len;
		return len;
	}
	,__class__: haxe_io_BytesInput
});
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__ : true, __constructs__ : ["UTF8","RawNative"]
	,UTF8: {_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
haxe_io_Encoding.__empty_constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
var haxe_io_Eof = function() {
};
$hxClasses["haxe.io.Eof"] = haxe_io_Eof;
haxe_io_Eof.__name__ = true;
haxe_io_Eof.prototype = {
	toString: function() {
		return "Eof";
	}
	,__class__: haxe_io_Eof
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__ : true, __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"]
	,Blocked: {_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_.__params__ = ["e"],$_)
};
haxe_io_Error.__empty_constructs__ = [haxe_io_Error.Blocked,haxe_io_Error.Overflow,haxe_io_Error.OutsideBounds];
var haxe_io_Path = function(path) {
	switch(path) {
	case ".":case "..":
		this.dir = path;
		this.file = "";
		return;
	}
	var c1 = path.lastIndexOf("/");
	var c2 = path.lastIndexOf("\\");
	if(c1 < c2) {
		this.dir = HxOverrides.substr(path,0,c2);
		path = HxOverrides.substr(path,c2 + 1,null);
		this.backslash = true;
	} else if(c2 < c1) {
		this.dir = HxOverrides.substr(path,0,c1);
		path = HxOverrides.substr(path,c1 + 1,null);
	} else {
		this.dir = null;
	}
	var cp = path.lastIndexOf(".");
	if(cp != -1) {
		this.ext = HxOverrides.substr(path,cp + 1,null);
		this.file = HxOverrides.substr(path,0,cp);
	} else {
		this.ext = null;
		this.file = path;
	}
};
$hxClasses["haxe.io.Path"] = haxe_io_Path;
haxe_io_Path.__name__ = true;
haxe_io_Path.withoutExtension = function(path) {
	var s = new haxe_io_Path(path);
	s.ext = null;
	return s.toString();
};
haxe_io_Path.prototype = {
	toString: function() {
		return (this.dir == null ? "" : this.dir + (this.backslash ? "\\" : "/")) + this.file + (this.ext == null ? "" : "." + this.ext);
	}
	,__class__: haxe_io_Path
};
var haxe_xml_Printer = function(pretty) {
	this.output = new StringBuf();
	this.pretty = pretty;
};
$hxClasses["haxe.xml.Printer"] = haxe_xml_Printer;
haxe_xml_Printer.__name__ = true;
haxe_xml_Printer.print = function(xml,pretty) {
	if(pretty == null) {
		pretty = false;
	}
	var printer = new haxe_xml_Printer(pretty);
	printer.writeNode(xml,"");
	return printer.output.b;
};
haxe_xml_Printer.prototype = {
	writeNode: function(value,tabs) {
		switch(value.nodeType) {
		case 0:
			this.output.b += Std.string(tabs + "<");
			if(value.nodeType != Xml.Element) {
				throw new js__$Boot_HaxeError("Bad node type, expected Element but found " + value.nodeType);
			}
			this.output.b += Std.string(value.nodeName);
			var attribute = value.attributes();
			while(attribute.hasNext()) {
				var attribute1 = attribute.next();
				this.output.b += Std.string(" " + attribute1 + "=\"");
				var input = StringTools.htmlEscape(value.get(attribute1),true);
				this.output.b += Std.string(input);
				this.output.b += "\"";
			}
			if(this.hasChildren(value)) {
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
				if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
					throw new js__$Boot_HaxeError("Bad node type, expected Element or Document but found " + value.nodeType);
				}
				var child = HxOverrides.iter(value.children);
				while(child.hasNext()) {
					var child1 = child.next();
					this.writeNode(child1,this.pretty ? tabs + "\t" : tabs);
				}
				this.output.b += Std.string(tabs + "</");
				if(value.nodeType != Xml.Element) {
					throw new js__$Boot_HaxeError("Bad node type, expected Element but found " + value.nodeType);
				}
				this.output.b += Std.string(value.nodeName);
				this.output.b += ">";
				if(this.pretty) {
					this.output.b += "\n";
				}
			} else {
				this.output.b += "/>";
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 1:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw new js__$Boot_HaxeError("Bad node type, unexpected " + value.nodeType);
			}
			var nodeValue = value.nodeValue;
			if(nodeValue.length != 0) {
				var input1 = tabs + StringTools.htmlEscape(nodeValue);
				this.output.b += Std.string(input1);
				if(this.pretty) {
					this.output.b += "\n";
				}
			}
			break;
		case 2:
			this.output.b += Std.string(tabs + "<![CDATA[");
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw new js__$Boot_HaxeError("Bad node type, unexpected " + value.nodeType);
			}
			this.output.b += Std.string(value.nodeValue);
			this.output.b += "]]>";
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 3:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw new js__$Boot_HaxeError("Bad node type, unexpected " + value.nodeType);
			}
			var commentContent = value.nodeValue;
			var _this_r = new RegExp("[\n\r\t]+","g".split("u").join(""));
			commentContent = commentContent.replace(_this_r,"");
			commentContent = "<!--" + commentContent + "-->";
			this.output.b += tabs == null ? "null" : "" + tabs;
			var input2 = StringTools.trim(commentContent);
			this.output.b += Std.string(input2);
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 4:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw new js__$Boot_HaxeError("Bad node type, unexpected " + value.nodeType);
			}
			this.output.b += Std.string("<!DOCTYPE " + value.nodeValue + ">");
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 5:
			if(value.nodeType == Xml.Document || value.nodeType == Xml.Element) {
				throw new js__$Boot_HaxeError("Bad node type, unexpected " + value.nodeType);
			}
			this.output.b += Std.string("<?" + value.nodeValue + "?>");
			if(this.pretty) {
				this.output.b += "\n";
			}
			break;
		case 6:
			if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
				throw new js__$Boot_HaxeError("Bad node type, expected Element or Document but found " + value.nodeType);
			}
			var child2 = HxOverrides.iter(value.children);
			while(child2.hasNext()) {
				var child3 = child2.next();
				this.writeNode(child3,tabs);
			}
			break;
		}
	}
	,hasChildren: function(value) {
		if(value.nodeType != Xml.Document && value.nodeType != Xml.Element) {
			throw new js__$Boot_HaxeError("Bad node type, expected Element or Document but found " + value.nodeType);
		}
		var child = HxOverrides.iter(value.children);
		while(child.hasNext()) {
			var child1 = child.next();
			switch(child1.nodeType) {
			case 0:case 1:
				return true;
			case 2:case 3:
				if(child1.nodeType == Xml.Document || child1.nodeType == Xml.Element) {
					throw new js__$Boot_HaxeError("Bad node type, unexpected " + child1.nodeType);
				}
				if(StringTools.ltrim(child1.nodeValue).length != 0) {
					return true;
				}
				break;
			default:
			}
		}
		return false;
	}
	,__class__: haxe_xml_Printer
};
var haxe_zip_Compress = function() { };
$hxClasses["haxe.zip.Compress"] = haxe_zip_Compress;
haxe_zip_Compress.__name__ = true;
haxe_zip_Compress.run = function(s,level) {
	var data = s.b;
	var buffer = js_node_Zlib.deflateSync(new js_node_buffer_Buffer(data.buffer,data.byteOffset,s.length),{ level : level});
	return js_node_buffer__$Buffer_Helper.bytesOfBuffer(buffer);
};
var haxe_zip_Uncompress = function() { };
$hxClasses["haxe.zip.Uncompress"] = haxe_zip_Uncompress;
haxe_zip_Uncompress.__name__ = true;
haxe_zip_Uncompress.run = function(src,bufsize) {
	var data = src.b;
	var buffer = js_node_Zlib.inflateSync(new js_node_buffer_Buffer(data.buffer,data.byteOffset,src.length),bufsize == null ? { } : { chunkSize : bufsize});
	return js_node_buffer__$Buffer_Helper.bytesOfBuffer(buffer);
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
$hxClasses["js._Boot.HaxeError"] = js__$Boot_HaxeError;
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
	__class__: js__$Boot_HaxeError
});
var js_Boot = function() { };
$hxClasses["js.Boot"] = js_Boot;
js_Boot.__name__ = true;
js_Boot.getClass = function(o) {
	if((o instanceof Array) && o.__enum__ == null) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var n = e.__constructs__[o._hx_index];
			var con = e[n];
			if(con.__params__) {
				s += "\t";
				var tmp = n + "(";
				var _g = [];
				var _g1 = 0;
				var _g2 = con.__params__;
				while(_g1 < _g2.length) {
					var p = _g2[_g1];
					++_g1;
					_g.push(js_Boot.__string_rec(o[p],s));
				}
				return tmp + _g.join(",") + ")";
			} else {
				return n;
			}
		}
		if((o instanceof Array)) {
			var l = o.length;
			var i;
			var str = "[";
			s += "\t";
			var _g3 = 0;
			var _g11 = l;
			while(_g3 < _g11) {
				var i1 = _g3++;
				str += (i1 > 0 ? "," : "") + js_Boot.__string_rec(o[i1],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e1 ) {
			var e2 = (e1 instanceof js__$Boot_HaxeError) ? e1.val : e1;
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str1 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str1.length != 2) {
			str1 += ", \n";
		}
		str1 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str1 += "\n" + s + "}";
		return str1;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g = 0;
		var _g1 = intf.length;
		while(_g < _g1) {
			var i = _g++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		if((o instanceof Array)) {
			return o.__enum__ == null;
		} else {
			return false;
		}
		break;
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return true;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return ((o | 0) === o);
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if((o instanceof cl)) {
					return true;
				}
				if(js_Boot.__interfLoop(js_Boot.getClass(o),cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if((o instanceof cl)) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return $hxEnums[o.__enum__] == cl;
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var js_node_Fs = require("fs");
var js_node_Zlib = require("zlib");
var js_node_buffer_Buffer = require("buffer").Buffer;
var js_node_buffer__$Buffer_Helper = function() { };
$hxClasses["js.node.buffer._Buffer.Helper"] = js_node_buffer__$Buffer_Helper;
js_node_buffer__$Buffer_Helper.__name__ = true;
js_node_buffer__$Buffer_Helper.bytesOfBuffer = function(b) {
	var o = Object.create(haxe_io_Bytes.prototype);
	o.length = b.byteLength;
	o.b = b;
	b.bufferValue = b;
	b.hxBytes = o;
	b.bytes = b;
	return o;
};
var mcli_Dispatch = function(args) {
	this.args = args.slice();
	this.args.reverse();
	this.depth = 0;
};
$hxClasses["mcli.Dispatch"] = mcli_Dispatch;
mcli_Dispatch.__name__ = true;
mcli_Dispatch.argToString = function(arg,argSize,screenSize) {
	if(argSize == null) {
		argSize = 30;
	}
	if(screenSize == null) {
		screenSize = mcli_Dispatch.getScreenSize();
	}
	var postfix = mcli_Dispatch.getPostfix(arg);
	var versions = mcli_Dispatch.getAliases(arg);
	if(versions.length == 0) {
		if(arg.description != null) {
			return arg.description;
		} else {
			return "";
		}
	}
	versions.sort(function(s1,s2) {
		return Reflect.compare(s1.length,s2.length);
	});
	var desc = arg.description != null ? arg.description : "";
	var ret = new StringBuf();
	ret.b += "  ";
	var argsTxt = StringTools.rpad(versions.map(function(v) {
		return v;
	}).join(", ") + postfix," ",argSize);
	ret.b += argsTxt == null ? "null" : "" + argsTxt;
	if(argsTxt.length > argSize) {
		ret.b += "\n";
		var _g = 0;
		var _g1 = argSize;
		while(_g < _g1) {
			var i = _g++;
			ret.b += " ";
		}
	}
	ret.b += "   ";
	if(arg.description != null) {
		ret.b += Std.string(arg.description);
	}
	var consolidated = ret.b;
	var inNewline = false;
	if(consolidated.length > screenSize) {
		ret = new StringBuf();
		var c = consolidated.split(" ");
		var ccount = 0;
		var _g2 = 0;
		while(_g2 < c.length) {
			var word = c[_g2];
			++_g2;
			if(inNewline && word == "") {
				continue;
			} else {
				inNewline = false;
			}
			ccount += word.length + 1;
			if(ccount >= screenSize) {
				ret.b += String.fromCodePoint(10);
				var _g3 = 0;
				var _g11 = argSize + 7;
				while(_g3 < _g11) {
					var i1 = _g3++;
					ret.b += " ";
				}
				ccount = word.length + 1 + argSize + 8;
				inNewline = true;
				if(word == "") {
					continue;
				}
			}
			ret.b += word == null ? "null" : "" + word;
			ret.b += " ";
		}
		return ret.b;
	} else {
		return consolidated;
	}
};
mcli_Dispatch.showUsageOf = function(args,screenSize) {
	if(screenSize == null) {
		screenSize = mcli_Dispatch.getScreenSize();
	}
	var maxSize = 0;
	var _g = 0;
	while(_g < args.length) {
		var arg = args[_g];
		++_g;
		if(arg.name == "runDefault") {
			continue;
		}
		var postfixSize = mcli_Dispatch.getPostfix(arg).length;
		var size = arg.command.length + postfixSize + 3;
		if(arg.aliases != null) {
			var _g1 = 0;
			var _g11 = arg.aliases;
			while(_g1 < _g11.length) {
				var a = _g11[_g1];
				++_g1;
				size += a.length + 3;
			}
		}
		if(size > maxSize) {
			maxSize = size;
		}
	}
	if(maxSize > screenSize / 2.5) {
		maxSize = screenSize / 2.5 | 0;
	}
	var buf_b = "";
	var _g12 = 0;
	while(_g12 < args.length) {
		var arg1 = args[_g12];
		++_g12;
		if(arg1.name == "runDefault") {
			continue;
		}
		var str = mcli_Dispatch.argToString(arg1,maxSize,screenSize);
		if(str.length > 0) {
			buf_b += str == null ? "null" : "" + str;
			buf_b += String.fromCodePoint(10);
		}
	}
	return buf_b;
};
mcli_Dispatch.getScreenSize = function(defaultSize) {
	if(defaultSize == null) {
		defaultSize = 80;
	}
	return defaultSize;
};
mcli_Dispatch.getAliases = function(arg) {
	var versions = arg.aliases != null ? arg.aliases.concat([arg.command]) : [arg.command];
	versions = versions.filter(function(s) {
		if(s != null) {
			return s != "";
		} else {
			return false;
		}
	});
	var prefix = "-";
	if(arg.kind == mcli_internal_Kind.SubDispatch || arg.kind == mcli_internal_Kind.Message) {
		prefix = "";
	}
	var _g = [];
	var _g1 = 0;
	while(_g1 < versions.length) {
		var v = versions[_g1];
		++_g1;
		_g.push(v.length == 1 ? prefix + mcli_internal_Tools.toDashSep(v) : prefix + prefix + mcli_internal_Tools.toDashSep(v));
	}
	return _g;
};
mcli_Dispatch.getPostfix = function(arg) {
	var _g = arg.kind;
	switch(_g._hx_index) {
	case 2:
		var v = _g.value;
		var k = _g.key;
		return " " + k.name + "[=" + v.name + "]";
	case 3:
		return " <" + arg.name + ">";
	case 4:
		var vargs = _g.varArgs;
		var args = _g.args;
		var postfix = "";
		var _g1 = 0;
		while(_g1 < args.length) {
			var arg1 = args[_g1];
			++_g1;
			postfix += (arg1.opt ? " [" : " <") + mcli_internal_Tools.toDashSep(arg1.name) + (arg1.opt ? "]" : ">");
		}
		if(vargs != null) {
			postfix += " [arg1 [arg2 ...[argN]]]";
		}
		return postfix;
	default:
		return "";
	}
};
mcli_Dispatch.addDecoderRuntime = function(name,d) {
	if(mcli_Dispatch.decoders == null) {
		mcli_Dispatch.decoders = new haxe_ds_StringMap();
	}
	var _this = mcli_Dispatch.decoders;
	if(__map_reserved[name] != null) {
		_this.setReserved(name,d);
	} else {
		_this.h[name] = d;
	}
};
mcli_Dispatch.decode = function(a,type) {
	switch(type) {
	case "Float":
		var ret = parseFloat(a);
		if(isNaN(ret)) {
			throw new js__$Boot_HaxeError(mcli_DispatchError.ArgumentFormatError(type,a));
		}
		return ret;
	case "Int":
		var ret1 = Std.parseInt(a);
		if(ret1 == null) {
			throw new js__$Boot_HaxeError(mcli_DispatchError.ArgumentFormatError(type,a));
		}
		return ret1;
	case "String":
		return a;
	default:
		var d;
		if(mcli_Dispatch.decoders != null) {
			var _this = mcli_Dispatch.decoders;
			d = __map_reserved[type] != null ? _this.getReserved(type) : _this.h[type];
		} else {
			d = null;
		}
		if(d == null) {
			var dt = $hxClasses[type];
			if(dt != null && Object.prototype.hasOwnProperty.call(dt,"fromString")) {
				d = dt;
			}
		}
		if(d == null) {
			var dt2 = $hxClasses[type + "Decoder"];
			if(dt2 != null && Object.prototype.hasOwnProperty.call(dt2,"fromString")) {
				d = dt2;
			}
		}
		if(d == null) {
			var e = $hxEnums[type];
			if(e != null) {
				var all = e.__empty_constructs__.slice();
				if(all.length > 0 && all.length == e.__constructs__.slice().length) {
					var _g = 0;
					while(_g < all.length) {
						var v = all[_g];
						++_g;
						if(a == mcli_internal_Tools.toDashSep(Std.string(v))) {
							return v;
						}
					}
					throw new js__$Boot_HaxeError(mcli_DispatchError.ArgumentFormatError(type,a));
				}
			}
		}
		if(d == null) {
			throw new js__$Boot_HaxeError(mcli_DispatchError.DecoderNotFound(type));
		}
		return d.fromString(a);
	}
};
mcli_Dispatch.isArgument = function(str) {
	if(HxOverrides.cca(str,0) == 45) {
		var code = HxOverrides.cca(str,1);
		if(code >= 48 && code <= 57 || code == 46) {
			return false;
		} else {
			return true;
		}
	}
	return false;
};
mcli_Dispatch.prototype = {
	errln: function(s) {
		haxe_Log.trace(s,null);
	}
	,println: function(s) {
		haxe_Log.trace(s,null);
	}
	,dispatch: function(v,handleExceptions) {
		if(handleExceptions == null) {
			handleExceptions = true;
		}
		this.depth++;
		try {
			this._dispatch(v,handleExceptions);
			this.depth--;
		} catch( e ) {
			var e1 = (e instanceof js__$Boot_HaxeError) ? e.val : e;
			this.depth--;
			throw js__$Boot_HaxeError.wrap(e1);
		}
	}
	,_dispatch: function(v,handleExceptions) {
		var _gthis = this;
		if(handleExceptions) {
			try {
				this._dispatch(v,false);
			} catch( e ) {
				var e1 = (e instanceof js__$Boot_HaxeError) ? e.val : e;
				if(js_Boot.__instanceof(e1,mcli_DispatchError)) {
					var e2 = e1;
					switch(e2._hx_index) {
					case 0:
						var a = e2.arg;
						this.errln("ERROR: Unknown argument: " + a);
						break;
					case 1:
						var p = e2.passed;
						var t = e2.type;
						this.errln("ERROR: Unrecognized format for " + t + ". Passed " + p);
						break;
					case 2:
						var t1 = e2.type;
						this.errln("[mcli error] No Decoder found for type " + t1);
						break;
					case 3:
						var name = e2.name;
						var opt = e2.opt;
						if(opt == "--run-default") {
							this.errln("ERROR: The argument " + name + " is required");
						} else {
							var name1 = e2.name;
							var opt1 = e2.opt;
							name1 = name1 != null ? " (" + name1 + ")" : "";
							this.errln("ERROR: The option " + opt1 + " requires an argument " + name1 + ", but no argument was passed");
						}
						break;
					case 4:
						this.errln("ERROR: Missing arguments");
						break;
					case 5:
						this.errln("ERROR: Too many arguments");
						break;
					}
					this.println(v.showUsage());
				} else {
					throw e;
				}
			}
			return;
		}
		var defs = v.getArguments();
		var names = new haxe_ds_StringMap();
		var _g = 0;
		while(_g < defs.length) {
			var arg = defs[_g];
			++_g;
			var _g1 = 0;
			var _g11 = mcli_Dispatch.getAliases(arg);
			while(_g1 < _g11.length) {
				var a1 = _g11[_g1];
				++_g1;
				if(__map_reserved[a1] != null) {
					names.setReserved(a1,arg);
				} else {
					names.h[a1] = arg;
				}
			}
		}
		var didCall = false;
		var defaultRan = false;
		var delays = [];
		var runArgument = function(arg1,argDef) {
			var _g12 = argDef.kind;
			switch(_g12._hx_index) {
			case 0:
				throw new js__$Boot_HaxeError(mcli_DispatchError.UnknownArgument(arg1));
			case 1:
				Reflect.setProperty(v,argDef.name,true);
				break;
			case 2:
				var arr = _g12.valueIsArray;
				var val = _g12.value;
				var key = _g12.key;
				var map = Reflect.getProperty(v,argDef.name);
				var n = _gthis.args.pop();
				var toAdd = [];
				while(n != null && mcli_Dispatch.isArgument(n)) {
					toAdd.push(n);
					n = _gthis.args.pop();
				}
				if(n == null) {
					throw new js__$Boot_HaxeError(mcli_DispatchError.MissingOptionArgument(arg1,key.name));
				}
				var kv = n.split("=");
				var k = mcli_Dispatch.decode(kv[0],key.t);
				var v1 = null;
				if(kv[1] != null) {
					v1 = mcli_Dispatch.decode(kv[1],val.t);
				}
				var oldv = map.get(k);
				if(oldv != null) {
					if(arr) {
						oldv.push(v1);
					}
				} else if(arr) {
					map.set(k,[v1]);
				} else {
					map.set(k,v1);
				}
				if(toAdd.length > 0) {
					toAdd.reverse();
					_gthis.args = _gthis.args.concat(toAdd);
				}
				break;
			case 3:
				var t2 = _g12.t;
				var n1 = _gthis.args.pop();
				var toAdd1 = [];
				while(n1 != null && mcli_Dispatch.isArgument(n1)) {
					toAdd1.push(n1);
					n1 = _gthis.args.pop();
				}
				if(n1 == null) {
					throw new js__$Boot_HaxeError(mcli_DispatchError.MissingOptionArgument(arg1));
				}
				var val1 = mcli_Dispatch.decode(n1,t2);
				Reflect.setProperty(v,argDef.name,val1);
				if(toAdd1.length > 0) {
					toAdd1.reverse();
					_gthis.args = _gthis.args.concat(toAdd1);
				}
				break;
			case 4:
				var varArg = _g12.varArgs;
				var fargs = _g12.args;
				didCall = true;
				var applied = [];
				var toAdd2 = [];
				var origArg = arg1;
				var _g13 = 0;
				while(_g13 < fargs.length) {
					var fa = fargs[_g13];
					++_g13;
					arg1 = _gthis.args.pop();
					while(arg1 != null && mcli_Dispatch.isArgument(arg1)) {
						toAdd2.push(arg1);
						arg1 = _gthis.args.pop();
					}
					if(arg1 == null && !fa.opt) {
						throw new js__$Boot_HaxeError(mcli_DispatchError.MissingOptionArgument(origArg,fa.name));
					}
					var runArgument1 = mcli_Dispatch.decode(arg1,fa.t);
					applied.push(runArgument1);
				}
				if(varArg != null) {
					var va = [];
					while(_gthis.args.length > 0) {
						var arg2 = _gthis.args.pop();
						if(mcli_Dispatch.isArgument(arg2)) {
							_gthis.args.push(arg2);
							break;
						} else {
							va.push(mcli_Dispatch.decode(arg2,varArg));
						}
					}
					applied.push(va);
				}
				delays.push(function() {
					Reflect.field(v,argDef.name).apply(v,applied);
				});
				if(toAdd2.length != 0) {
					toAdd2.reverse();
					_gthis.args = _gthis.args.concat(toAdd2);
				}
				break;
			case 5:
				didCall = true;
				var _g14 = 0;
				while(_g14 < delays.length) {
					var d = delays[_g14];
					++_g14;
					d();
				}
				delays = [];
				Reflect.field(v,argDef.name).apply(v,[_gthis]);
				break;
			}
		};
		var getDefaultAlias = function() {
			if(__map_reserved["--run-default"] != null ? names.existsReserved("--run-default") : names.h.hasOwnProperty("--run-default")) {
				return "--run-default";
			} else if(__map_reserved["run-default"] != null ? names.existsReserved("run-default") : names.h.hasOwnProperty("run-default")) {
				return "run-default";
			} else {
				return "";
			}
		};
		while(this.args.length > 0) {
			var arg3 = this.args.pop();
			var argDef1 = __map_reserved[arg3] != null ? names.getReserved(arg3) : names.h[arg3];
			if(argDef1 == null) {
				if(!mcli_Dispatch.isArgument(arg3)) {
					if(!defaultRan && !v._preventDefault) {
						var key1 = getDefaultAlias();
						argDef1 = __map_reserved[key1] != null ? names.getReserved(key1) : names.h[key1];
						if(argDef1 != null) {
							defaultRan = true;
						}
						this.args.push(arg3);
					}
				} else if(arg3.length > 2 && HxOverrides.cca(arg3,1) != 45) {
					var a2 = HxOverrides.substr(arg3,1,null).split("").map(function(v2) {
						return "-" + v2;
					});
					a2.reverse();
					this.args = this.args.concat(a2);
					continue;
				}
			}
			if(argDef1 == null) {
				if(arg3 != null) {
					if(didCall == false && !v._preventDefault || this.depth == 1) {
						throw new js__$Boot_HaxeError(mcli_DispatchError.UnknownArgument(arg3));
					} else {
						this.args.push(arg3);
						break;
					}
				} else {
					throw new js__$Boot_HaxeError(mcli_DispatchError.MissingArgument);
				}
			}
			runArgument(arg3,argDef1);
		}
		var defaultAlias = getDefaultAlias();
		var argDef2 = __map_reserved[defaultAlias] != null ? names.getReserved(defaultAlias) : names.h[defaultAlias];
		var _g15 = 0;
		while(_g15 < delays.length) {
			var d1 = delays[_g15];
			++_g15;
			d1();
		}
		delays = [];
		if(argDef2 == null) {
			if(!didCall) {
				throw new js__$Boot_HaxeError(mcli_DispatchError.MissingArgument);
			}
		} else if(!didCall && !v._preventDefault) {
			runArgument(defaultAlias,argDef2);
		} else if(!defaultRan && !v._preventDefault) {
			var _g2 = argDef2.kind;
			if(_g2._hx_index == 4) {
				var args = _g2.args;
				if(!Lambda.exists(args,function(a3) {
					return !a3.opt;
				})) {
					runArgument(defaultAlias,argDef2);
				}
			}
		}
		var _g21 = 0;
		while(_g21 < delays.length) {
			var d2 = delays[_g21];
			++_g21;
			d2();
		}
	}
	,__class__: mcli_Dispatch
};
var mcli_DispatchError = $hxEnums["mcli.DispatchError"] = { __ename__ : true, __constructs__ : ["UnknownArgument","ArgumentFormatError","DecoderNotFound","MissingOptionArgument","MissingArgument","TooManyArguments"]
	,UnknownArgument: ($_=function(arg) { return {_hx_index:0,arg:arg,__enum__:"mcli.DispatchError",toString:$estr}; },$_.__params__ = ["arg"],$_)
	,ArgumentFormatError: ($_=function(type,passed) { return {_hx_index:1,type:type,passed:passed,__enum__:"mcli.DispatchError",toString:$estr}; },$_.__params__ = ["type","passed"],$_)
	,DecoderNotFound: ($_=function(type) { return {_hx_index:2,type:type,__enum__:"mcli.DispatchError",toString:$estr}; },$_.__params__ = ["type"],$_)
	,MissingOptionArgument: ($_=function(opt,name) { return {_hx_index:3,opt:opt,name:name,__enum__:"mcli.DispatchError",toString:$estr}; },$_.__params__ = ["opt","name"],$_)
	,MissingArgument: {_hx_index:4,__enum__:"mcli.DispatchError",toString:$estr}
	,TooManyArguments: {_hx_index:5,__enum__:"mcli.DispatchError",toString:$estr}
};
mcli_DispatchError.__empty_constructs__ = [mcli_DispatchError.MissingArgument,mcli_DispatchError.TooManyArguments];
var mcli_internal_Tools = function() { };
$hxClasses["mcli.internal.Tools"] = mcli_internal_Tools;
mcli_internal_Tools.__name__ = true;
mcli_internal_Tools.toDashSep = function(s) {
	if(s.length <= 1) {
		return s;
	}
	var buf_b = "";
	var first = true;
	var _g = 0;
	var _g1 = s.length;
	while(_g < _g1) {
		var i = _g++;
		var chr = HxOverrides.cca(s,i);
		if(chr >= 65 && chr <= 90) {
			if(!first) {
				buf_b += String.fromCodePoint(45);
			}
			buf_b += String.fromCodePoint(chr - -32);
			first = true;
		} else {
			buf_b += String.fromCodePoint(chr);
			first = false;
		}
	}
	return buf_b;
};
mcli_internal_Tools.parseComments = function(c) {
	var ret = [];
	var curTag = null;
	var txt = new StringBuf();
	var _g = 0;
	var _g1 = c.split("\n");
	while(_g < _g1.length) {
		var ln = _g1[_g];
		++_g;
		var i = 0;
		var len = ln.length;
		var foundTab = false;
		_hx_loop2: while(i < len) switch(ln.charCodeAt(i)) {
		case 9:
			++i;
			foundTab = true;
			break;
		case 32:
			if(!foundTab || i > 0 && ln.charCodeAt(i - 1) == 42) {
				++i;
			} else {
				break _hx_loop2;
			}
			break;
		case 42:
			++i;
			break;
		case 64:
			var t = txt.b;
			txt = new StringBuf();
			if(curTag != null || t.length > 0) {
				ret.push({ tag : curTag, contents : t});
			}
			var begin = ++i;
			_hx_loop3: while(i < len) switch(ln.charCodeAt(i)) {
			case 9:case 32:
				break _hx_loop3;
			default:
				++i;
			}
			curTag = HxOverrides.substr(ln,begin,i - begin);
			break _hx_loop2;
		default:
			break _hx_loop2;
		}
		if(i < len) {
			var x = StringTools.rtrim(StringTools.replace(HxOverrides.substr(ln,i,null),"\r",""));
			txt.b += Std.string(x);
			txt.b += String.fromCodePoint(32);
		}
		txt.b += String.fromCodePoint(10);
	}
	var t1 = StringTools.trim(txt.b);
	if(curTag != null || t1.length > 0) {
		ret.push({ tag : curTag, contents : t1});
	}
	return ret;
};
var sys_io_FileInput = function(fd) {
	this.fd = fd;
	this.pos = 0;
};
$hxClasses["sys.io.FileInput"] = sys_io_FileInput;
sys_io_FileInput.__name__ = true;
sys_io_FileInput.__super__ = haxe_io_Input;
sys_io_FileInput.prototype = $extend(haxe_io_Input.prototype,{
	readByte: function() {
		var buf = new js_node_buffer_Buffer(1);
		var bytesRead;
		try {
			bytesRead = js_node_Fs.readSync(this.fd,buf,0,1,this.pos);
		} catch( e ) {
			var e1 = (e instanceof js__$Boot_HaxeError) ? e.val : e;
			if(e1.code == "EOF") {
				throw new js__$Boot_HaxeError(new haxe_io_Eof());
			} else {
				throw new js__$Boot_HaxeError(haxe_io_Error.Custom(e1));
			}
		}
		if(bytesRead == 0) {
			throw new js__$Boot_HaxeError(new haxe_io_Eof());
		}
		this.pos++;
		return buf[0];
	}
	,readBytes: function(s,pos,len) {
		var data = s.b;
		var buf = new js_node_buffer_Buffer(data.buffer,data.byteOffset,s.length);
		var bytesRead;
		try {
			bytesRead = js_node_Fs.readSync(this.fd,buf,pos,len,this.pos);
		} catch( e ) {
			var e1 = (e instanceof js__$Boot_HaxeError) ? e.val : e;
			if(e1.code == "EOF") {
				throw new js__$Boot_HaxeError(new haxe_io_Eof());
			} else {
				throw new js__$Boot_HaxeError(haxe_io_Error.Custom(e1));
			}
		}
		if(bytesRead == 0) {
			throw new js__$Boot_HaxeError(new haxe_io_Eof());
		}
		this.pos += bytesRead;
		return bytesRead;
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
	,seek: function(p,pos) {
		switch(pos._hx_index) {
		case 0:
			this.pos = p;
			break;
		case 1:
			this.pos += p;
			break;
		case 2:
			this.pos = js_node_Fs.fstatSync(this.fd).size + p;
			break;
		}
	}
	,tell: function() {
		return this.pos;
	}
	,eof: function() {
		return this.pos >= js_node_Fs.fstatSync(this.fd).size;
	}
	,__class__: sys_io_FileInput
});
var sys_io_FileOutput = function(fd) {
	this.fd = fd;
	this.pos = 0;
};
$hxClasses["sys.io.FileOutput"] = sys_io_FileOutput;
sys_io_FileOutput.__name__ = true;
sys_io_FileOutput.__super__ = haxe_io_Output;
sys_io_FileOutput.prototype = $extend(haxe_io_Output.prototype,{
	writeByte: function(b) {
		var buf = new js_node_buffer_Buffer(1);
		buf[0] = b;
		js_node_Fs.writeSync(this.fd,buf,0,1,this.pos);
		this.pos++;
	}
	,writeBytes: function(s,pos,len) {
		var data = s.b;
		var buf = new js_node_buffer_Buffer(data.buffer,data.byteOffset,s.length);
		var wrote = js_node_Fs.writeSync(this.fd,buf,pos,len,this.pos);
		this.pos += wrote;
		return wrote;
	}
	,close: function() {
		js_node_Fs.closeSync(this.fd);
	}
	,seek: function(p,pos) {
		switch(pos._hx_index) {
		case 0:
			this.pos = p;
			break;
		case 1:
			this.pos += p;
			break;
		case 2:
			this.pos = js_node_Fs.fstatSync(this.fd).size + p;
			break;
		}
	}
	,tell: function() {
		return this.pos;
	}
	,__class__: sys_io_FileOutput
});
var sys_io_FileSeek = $hxEnums["sys.io.FileSeek"] = { __ename__ : true, __constructs__ : ["SeekBegin","SeekCur","SeekEnd"]
	,SeekBegin: {_hx_index:0,__enum__:"sys.io.FileSeek",toString:$estr}
	,SeekCur: {_hx_index:1,__enum__:"sys.io.FileSeek",toString:$estr}
	,SeekEnd: {_hx_index:2,__enum__:"sys.io.FileSeek",toString:$estr}
};
sys_io_FileSeek.__empty_constructs__ = [sys_io_FileSeek.SeekBegin,sys_io_FileSeek.SeekCur,sys_io_FileSeek.SeekEnd];
function $getIterator(o) { if( o instanceof Array ) return HxOverrides.iter(o); else return o.iterator(); }
$hxClasses["Math"] = Math;
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.prototype.__class__ = $hxClasses["String"] = String;
String.__name__ = true;
$hxClasses["Array"] = Array;
Array.__name__ = true;
var Int = { };
var Dynamic = { };
var Float = Number;
var Bool = Boolean;
var Class = { };
var Enum = { };
var __map_reserved = {};
Object.defineProperty(js__$Boot_HaxeError.prototype,"message",{ get : function() {
	return String(this.val);
}});
MapWriter.ARGUMENTS = [{ name : "tileWidth", description : null, command : "tileWidth", kind : mcli_internal_Kind.Var("Int"), aliases : []},{ name : "tileHeight", description : null, command : "tileHeight", kind : mcli_internal_Kind.Var("Int"), aliases : []},{ name : "inputImage", description : null, command : "inputImage", kind : mcli_internal_Kind.Var("String"), aliases : []},{ name : "inputTileset", description : null, command : "inputTileset", kind : mcli_internal_Kind.Var("String"), aliases : []},{ name : "runDefault", description : null, command : "runDefault", kind : mcli_internal_Kind.Function([],null), aliases : []},{ name : "help", description : null, command : "help", kind : mcli_internal_Kind.Function([],null), aliases : []}];
Tileset.findCounter = 0;
Xml.Element = 0;
Xml.PCData = 1;
Xml.Document = 6;
js_Boot.__toStr = ({ }).toString;
MapWriter.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);

//# sourceMappingURL=image-to-tmx.js.map